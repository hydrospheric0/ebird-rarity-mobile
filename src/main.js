import './styles.css'
import 'leaflet/dist/leaflet.css'
import L from 'leaflet'
import { API_BASE_URL, fetchWorkerHealth } from './config/api.js'
import { getYoloSpeciesInfo, getSpeciesMapLabel, getAbaCodeOverride } from './data/species-reference.js'

const BUILD_TAG = typeof __BUILD_TAG__ !== 'undefined' ? __BUILD_TAG__ : 'dev'

const YOLO_COUNTY_REGION = 'US-CA-113'

const EBIRD_API_KEY_STORAGE_KEY = 'mrm_ebird_api_key'

const app = document.querySelector('#app')

app.innerHTML = `
  <div id="appShell" class="app-shell">
    <div id="apiKeyGate" class="api-key-gate" hidden>
      <div class="api-key-card" role="dialog" aria-modal="true" aria-labelledby="apiKeyTitle">
        <button id="apiKeyCloseBtn" class="api-key-close-btn" type="button" aria-label="Close" title="Close">×</button>
        <h2 id="apiKeyTitle">eBird API key required</h2>
        <label class="api-key-field" for="apiKeyInput">
          <span>API key:</span>
          <div class="api-key-input-row">
            <input id="apiKeyInput" class="api-key-input" type="password" inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false" placeholder="Paste eBird API key">
            <button id="apiKeyToggleBtn" class="menu-btn api-key-visibility-btn" type="button" aria-label="Show API key" aria-pressed="false" title="Show API key">
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7-10-7-10-7z"></path>
                <circle cx="12" cy="12" r="3"></circle>
              </svg>
            </button>
          </div>
        </label>
        <div class="api-key-actions">
          <button id="apiKeySaveBtn" class="primary" type="button">Save key</button>
          <button id="apiKeyOpenBtn" class="menu-btn" type="button">eBird API keygen</button>
        </div>
        <ul class="api-key-notes" aria-label="API key notes">
          <li>If you’re already signed in on eBird in this browser, that page should show your key. Paste it here to continue.</li>
          <li>This key is only stored in your browser session and cannot be seen or read by others.</li>
          <li>When your session expires/resets you have to enter it again.</li>
        </ul>
        <p id="apiKeyError" class="api-key-error" aria-live="polite"></p>
      </div>
    </div>
    <header class="app-header">
      <h1 class="app-title">eBird County Rarities</h1>

      <section id="statusPopover" class="status-popover status-hidden" aria-hidden="true">
        <div class="row">
          <span>API Connectivity</span>
          <span id="apiStatus" class="badge warn">Checking...</span>
        </div>
        <p id="apiDetail" class="detail"></p>
        <p id="buildInfo" class="detail">Build: pending</p>

        <div class="row">
          <span>Perf</span>
          <span id="perfBadge" class="badge" style="font-size:0.65rem;letter-spacing:0;min-width:0;padding:0.1rem 0.4rem">—</span>
        </div>
        <p id="perfDetail" class="detail" style="font-family:monospace;font-size:0.62rem;white-space:pre;line-height:1.55"></p>

        <div class="row">
          <span>My Location</span>
          <span id="locationStatus" class="badge warn">Waiting...</span>
        </div>
        <p id="locationDetail" class="detail">iOS tip: choose "Allow While Using App" and keep "Precise Location" enabled for fine-grained positioning.</p>
        <button id="retryLocation" class="primary" type="button">Use My Location</button>

        <div class="filter-group">
          <label for="filterDaysBack" class="filter-label">Days Back: <span id="filterDaysBackValue">14</span></label>
          <input id="filterDaysBack" class="filter-slider" type="range" min="1" max="14" value="14" step="1">
        </div>
        <div class="filter-group">
          <label for="filterAbaMin" class="filter-label">ABA Code ≥ <span id="filterAbaMinValue">1</span></label>
          <input id="filterAbaMin" class="filter-slider" type="range" min="1" max="6" value="1" step="1">
        </div>
      </section>
    </header>

    <section class="map-strip">
      <div id="map" class="map"></div>
      <div class="map-top-right">
        <button id="mapFullscreenToggle" class="map-ctrl-btn" type="button" aria-pressed="false" aria-label="Toggle fullscreen map" title="Fullscreen">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
        </button>
        <button id="mapBasemapToggle" class="map-ctrl-btn" type="button" aria-label="Toggle basemap" title="Toggle satellite/street">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
        </button>
        <button id="mapLocateBtn" class="map-ctrl-btn" type="button" aria-label="Zoom to my location" title="My location">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor"><polygon points="12,3 19,20 12,16 5,20"/></svg>
        </button>
        <button id="mapLabelToggle" class="map-ctrl-btn" type="button" aria-pressed="true" aria-label="Toggle point labels" title="Toggle labels">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="18" height="13" rx="2"/><path d="M8 6V4a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v2"/><text x="12" y="17" text-anchor="middle" font-size="9" font-weight="700" font-family="sans-serif" fill="currentColor" stroke="none">B</text></svg>
        </button>
      </div>
      <div id="mapLoading" class="map-loading" aria-live="polite">
        <div class="spinner" aria-hidden="true"></div>
        <span id="mapLoadingText">Loading map…</span>
      </div>
    </section>

    <main class="app-main">
      <section id="panelMap" class="panel active">
        <section class="card table-card">
          <div id="countyPicker" class="county-picker" hidden>
            <div class="county-picker-title">Counties</div>
            <div id="countyPickerList" class="county-picker-list" role="listbox" aria-label="County list"></div>
            <div id="pickerAbaPills" class="top-aba-pills picker-aba-pills" aria-label="ABA counts"></div>
          </div>
          <div id="statePicker" class="county-picker" hidden>
            <div class="county-picker-title">States</div>
            <div id="statePickerList" class="county-picker-list" role="listbox" aria-label="State list"></div>
            <div id="statePickerAbaPills" class="top-aba-pills picker-aba-pills" aria-label="ABA counts"></div>
          </div>
          <div id="abaCodePicker" class="county-picker" hidden>
            <div class="county-picker-title">ABA Codes</div>
            <div id="abaCodePickerList" class="county-picker-list" role="listbox" aria-label="ABA code list"></div>
          </div>
          <span id="notableCount" style="display:none">—</span>
          <p id="notableMeta" style="display:none"></p>
          <div class="table-wrap">
            <table class="notable-table">
              <thead>
                <tr>
                  <th class="col-species sortable" id="thSpecies" data-sort="aba">Species<span class="sort-icon" aria-hidden="true"> ↓</span></th>
                  <th class="col-county">County</th>
                  <th class="col-date sortable" id="thLast" data-sort="last">Last<span class="sort-icon" aria-hidden="true"></span></th>
                  <th class="col-date sortable" id="thFirst" data-sort="first">First<span class="sort-icon" aria-hidden="true"></span></th>
                  <th class="col-reports">#</th>
                  <th class="col-vis"><input type="checkbox" id="toggleAllVis" title="Show / hide all" checked></th>
                  <th class="col-pin"></th>
                </tr>
              </thead>
              <tbody id="notableRows"></tbody>
            </table>
          </div>
          <p id="tableRenderStatus" class="detail" style="display:none">render: init</p>
        </section>
      </section>

      <section id="panelTable" class="panel">
        <section class="card">
          <h2>Table Mode</h2>
          <p class="detail">Table mode is the next step. Map mode is active first as requested.</p>
        </section>
      </section>
    </main>

    <div class="bottom-aba-bar" aria-label="ABA summary">
      <div class="aba-filter-label">Filter ABA code:</div>
      <div id="topAbaPills" class="top-aba-pills" aria-label="ABA counts"></div>
      <button id="sortModeBtn" class="top-menu-select top-menu-btn sort-toggle-btn" type="button" aria-label="Toggle sort (ABA/distance)" aria-pressed="false" title="Sort: ABA (tap for distance)"><span class="sort-toggle-icon" aria-hidden="true">⌖</span><span class="sort-toggle-label">ABA</span></button>
    </div>

    <nav class="bottom-menu bottom-select-menu" aria-label="Selection bar">
      <button id="headerStateBtn" class="top-menu-select top-menu-btn bottom-select" type="button" aria-label="State" title="Choose state">CA</button>
      <select id="headerStateSelect" class="top-menu-select" aria-label="State" hidden aria-hidden="true" tabindex="-1">
        <option value="US-CA">California</option>
      </select>

      <button id="headerCountyBtn" class="top-menu-select top-menu-btn bottom-select" type="button" aria-label="County" title="Choose county">Loading…</button>
      <select id="headerCountySelect" class="top-menu-select" aria-label="County" hidden aria-hidden="true" tabindex="-1">
        <option value="">Loading…</option>
      </select>

      <select id="headerDaysBackSelect" class="top-menu-select bottom-select" aria-label="Days back">
        <option value="1">1 day</option>
        <option value="3">3 days</option>
        <option value="7" selected>7 days</option>
        <option value="14">14 days</option>
      </select>

      <button id="bottomReloadBtn" class="menu-btn bottom-reload-btn" type="button" aria-label="Reload" title="Reload">
        <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="23 4 23 10 17 10" />
          <path d="M20.49 15a9 9 0 1 1 2.13-9" />
        </svg>
      </button>
    </nav>

    <div id="infoModal" class="app-modal" hidden>
      <div class="app-modal-backdrop" data-close="info"></div>
      <section class="app-modal-panel" role="dialog" aria-modal="true" aria-labelledby="infoTitle">
        <h2 id="infoTitle">About this page</h2>
        <p>This mobile view shows nearby eBird county rarities with map + table syncing.</p>
        <p>Use the top menu to switch county and days back, and use search to switch region/county quickly.</p>
        <p>© Bart Wickel, 2026</p>
        <section class="info-tech" aria-label="Technical metrics">
          <h3>Technical metrics</h3>
          <pre id="infoTechMetrics">Loading…</pre>
        </section>
        <section class="info-tech" aria-label="Tap debug">
          <h3>Tap debug (temporary)</h3>
          <label class="debug-toggle-row" for="tapDebugToggle">
            <input id="tapDebugToggle" type="checkbox">
            <span>Enable map tap resolution logs</span>
          </label>
          <pre id="tapDebugLog" class="tap-debug-log">Debug disabled</pre>
        </section>
        <button id="infoCloseBtn" class="primary" type="button">Close</button>
      </section>
    </div>

    <div id="searchPopover" class="menu-popover" hidden>
      <div class="menu-popover-card menu-popover-card--search" role="dialog" aria-modal="true" aria-labelledby="searchMenuTitle">
        <div id="searchMenuTitle" class="menu-popover-title">Search</div>
        <label class="menu-popover-field" for="searchRegionSelect">
          <span>Region:</span>
          <select id="searchRegionSelect" class="top-menu-select" aria-label="Search state"></select>
        </label>
        <label class="menu-popover-field" for="searchCountySelect">
          <span>County:</span>
          <select id="searchCountySelect" class="top-menu-select" aria-label="Search county"></select>
        </label>
        <label class="menu-popover-field" for="searchAbaMinInput">
          <span>ABA Code ≥ <span id="searchAbaMinValue">1</span></span>
          <input id="searchAbaMinInput" class="filter-slider" type="range" min="1" max="6" value="1" step="1" aria-label="Search ABA minimum">
        </label>
        <label class="menu-popover-field" for="searchDaysBackInput">
          <span>Days Back: <span id="searchDaysBackValue">7</span></span>
          <input id="searchDaysBackInput" class="filter-slider" type="range" min="1" max="14" value="7" step="1" aria-label="Search days back">
        </label>
        <div class="menu-popover-actions">
          <button id="searchApplyBtn" class="primary" type="button">Apply</button>
          <button id="searchCloseBtn" class="menu-btn" type="button">Close</button>
        </div>
      </div>
    </div>
  </div>
`

const apiStatus = document.querySelector('#apiStatus')
const apiDetail = document.querySelector('#apiDetail')
const buildInfo = document.querySelector('#buildInfo')
const locationStatus = document.querySelector('#locationStatus')
const locationDetail = document.querySelector('#locationDetail')
const retryLocationBtn = document.querySelector('#retryLocation')
const filterDaysBackInput = document.querySelector('#filterDaysBack')
const filterDaysBackValue = document.querySelector('#filterDaysBackValue')
const headerDaysBackSelect = document.querySelector('#headerDaysBackSelect')
const headerCountySelect = document.querySelector('#headerCountySelect')
const headerCountyBtn = document.querySelector('#headerCountyBtn')
const headerStateSelect = document.querySelector('#headerStateSelect')
const headerStateBtn = document.querySelector('#headerStateBtn')
const sortModeBtn = document.querySelector('#sortModeBtn')
const filterAbaMinInput = document.querySelector('#filterAbaMin')
const filterAbaMinValue = document.querySelector('#filterAbaMinValue')
const statusPopover = document.querySelector('#statusPopover')
const menuInfoBtn = document.querySelector('#menuInfo')
const menuSearchBtn = document.querySelector('#menuSearch')
const menuPinBtn = document.querySelector('#menuPin')
const menuRefreshBtn = document.querySelector('#menuRefresh')
const bottomReloadBtn = document.querySelector('#bottomReloadBtn')
const infoModal = document.querySelector('#infoModal')
const infoCloseBtn = document.querySelector('#infoCloseBtn')
const infoTechMetrics = document.querySelector('#infoTechMetrics')
const tapDebugToggle = document.querySelector('#tapDebugToggle')
const tapDebugLog = document.querySelector('#tapDebugLog')
const searchPopover = document.querySelector('#searchPopover')
const searchRegionSelect = document.querySelector('#searchRegionSelect')
const searchCountySelect = document.querySelector('#searchCountySelect')
const searchSpeciesSelect = document.querySelector('#searchSpeciesSelect')
const searchAbaMinInput = document.querySelector('#searchAbaMinInput')
const searchAbaMinValue = document.querySelector('#searchAbaMinValue')
const searchDaysBackInput = document.querySelector('#searchDaysBackInput')
const searchDaysBackValue = document.querySelector('#searchDaysBackValue')
const searchApplyBtn = document.querySelector('#searchApplyBtn')
const searchCloseBtn = document.querySelector('#searchCloseBtn')
const panelMap = document.querySelector('#panelMap')
const panelTable = document.querySelector('#panelTable')
const mapLoading = document.querySelector('#mapLoading')
const mapLoadingText = document.querySelector('#mapLoadingText')
const mapFullscreenToggleBtn = document.querySelector('#mapFullscreenToggle')
const mapBasemapToggleBtn = document.querySelector('#mapBasemapToggle')
const mapLocateBtn = document.querySelector('#mapLocateBtn')
const mapLabelToggleBtn = document.querySelector('#mapLabelToggle')
const appShell = document.querySelector('#appShell')
const apiKeyGate = document.querySelector('#apiKeyGate')
const apiKeyInput = document.querySelector('#apiKeyInput')
const apiKeyToggleBtn = document.querySelector('#apiKeyToggleBtn')
const apiKeySaveBtn = document.querySelector('#apiKeySaveBtn')
const apiKeyOpenBtn = document.querySelector('#apiKeyOpenBtn')
const apiKeyCloseBtn = document.querySelector('#apiKeyCloseBtn')
const apiKeyError = document.querySelector('#apiKeyError')
const notableCount = document.querySelector('#notableCount')
const notableMeta = document.querySelector('#notableMeta')
const topAbaPills = document.querySelector('#topAbaPills')
const countyPicker = document.querySelector('#countyPicker')
const countyPickerList = document.querySelector('#countyPickerList')
const pickerAbaPills = document.querySelector('#pickerAbaPills')
const statePicker = document.querySelector('#statePicker')
const statePickerList = document.querySelector('#statePickerList')
const statePickerAbaPills = document.querySelector('#statePickerAbaPills')
const abaCodePicker = document.querySelector('#abaCodePicker')
const abaCodePickerList = document.querySelector('#abaCodePickerList')
const notableRows = document.querySelector('#notableRows')
const tableRenderStatus = document.querySelector('#tableRenderStatus')
const perfBadge = document.querySelector('#perfBadge')
const perfDetail = document.querySelector('#perfDetail')

function syncPickerInsets() {
  const headerEl = document.querySelector('.app-header')
  if (!headerEl) return
  const rect = headerEl.getBoundingClientRect()
  const topPx = Math.max(0, Math.round(rect.bottom))
  document.documentElement.style.setProperty('--picker-top', `${topPx}px`)
}

window.addEventListener('resize', () => {
  syncPickerInsets()
})

// Initial layout sync (after first paint)
window.setTimeout(() => syncPickerInsets(), 0)
const API_TIMEOUT_MS = 8000
const COUNTY_NOTABLES_TIMEOUT_MS = 5500
const MAP_LABEL_MAX_POINTS = 80
const USER_LOCATION_ZOOM = 11
const MAP_POINTS_FIT_MAX_ZOOM = 11
const MAP_RENDER_BATCH_SIZE = 260
const BASE_TILE_OPTIONS = {
  updateWhenIdle: false,
  updateWhenZooming: false,
  keepBuffer: 8,
}

let map = null
let osmLayer = null
let satelliteLayer = null
let placeNameLayer = null
let mapPointRenderer = null
let currentBasemap = 'satellite'
let userDot = null
let accuracyCircle = null
let countyOverlay = null
let notableLayer = null
let speciesMarkers = new Map()
let neighborLayerRef = null
let activeOutlineLayerRef = null
let countyNameLayerRef = null
let countyDotLayerRef = null

// Anchor used to sort county lists by distance from the user's current/last county.
let lastCountyAnchorLat = null
let lastCountyAnchorLng = null
let lastCountyAnchorRegion = null

function setCountyDistanceAnchor(lat, lng, countyRegion = null) {
  const nLat = Number(lat)
  const nLng = Number(lng)
  if (!Number.isFinite(nLat) || !Number.isFinite(nLng)) return
  lastCountyAnchorLat = nLat
  lastCountyAnchorLng = nLng
  lastCountyAnchorRegion = countyRegion ? String(countyRegion).toUpperCase() : null
}
let hiddenSpecies = new Set()
let isMapFullscreen = false
let labelMode = 'abbr' // 'abbr', 'full', 'off'
let lastUserLat = null
let lastUserLng = null
let currentTableData = [] // all rows for re-sorting
let lastTableObservationSource = []
let sortState = { col: 'aba', dir: 'desc' } // col: 'aba'|'last'|'first'|'distance', dir: 'asc'|'desc'
let activeSortCountyRegion = YOLO_COUNTY_REGION
let pinnedSpecies = null
let preservePinnedSpeciesOnce = false
let latestLocationRequestId = 0
let latestNotablesLoadId = 0
let latestCountySwitchRequestId = 0
let currentRawObservations = []
let currentCountyName = null
let currentCountyRegion = null
const hiResCache = new Map() // countyRegion -> GeoJSON FeatureCollection
let hiResSwapInProgress = false
let currentActiveCountyCode = ''
let latestCountyContextGeojson = null
let filterDaysBack = 7
let filterAbaMin = 1
let selectedReviewFilter = null
let selectedSpecies = null
let countyPickerOptions = []
let selectedAbaCodes = new Set()
let abaCodePickerOptions = []
let latestSearchCountyOptionsRequestId = 0
let searchApplyInProgress = false
const TAP_DEBUG_STORAGE_KEY = 'mrm_tap_debug_enabled'
const TAP_DEBUG_MAX_ENTRIES = 40
let tapDebugEnabled = false
let tapDebugEvents = []
let lastMapRenderSignature = ''
let latestMapRenderId = 0
const countySummaryByRegion = new Map()
const stateSummaryByRegion = new Map()
const stateCountyOptionsCache = new Map()
const lastGoodObservationsByRegion = new Map()
let lastGoodObservationSnapshot = null

// ---------------------------------------------------------------------------
// Lightweight render-pipeline profiling
// ---------------------------------------------------------------------------
const PERF_STAGES = ['location', 'county', 'fetch', 'table', 'map']
const _perfStart = {}
const _perfResult = {}

function perfStart(stage) {
  _perfStart[stage] = performance.now()
}

function perfEnd(stage) {
  if (_perfStart[stage] == null) return
  _perfResult[stage] = Math.round(performance.now() - _perfStart[stage])
  delete _perfStart[stage]
  _updatePerfBadge()
}

function _updatePerfBadge() {
  if (!perfBadge) return
  const done = PERF_STAGES.filter((s) => _perfResult[s] != null)
  if (done.length === 0) return
  const total = done.reduce((sum, s) => sum + _perfResult[s], 0)
  const worst = done.reduce((m, s) => (_perfResult[s] > _perfResult[m] ? s : m), done[0])
  perfBadge.textContent = `${total} ms`
  perfBadge.className = `badge ${total < 1500 ? 'ok' : 'warn'}`
  if (perfDetail) {
    perfDetail.textContent = PERF_STAGES
      .filter((s) => _perfResult[s] != null)
      .map((s) => `${s.padEnd(9)}${String(_perfResult[s]).padStart(5)} ms${s === worst && done.length > 1 ? ' ◀' : ''}`)
      .join('\n')
  }
  updateRuntimeLog()
}

function perfReset() {
  PERF_STAGES.forEach((s) => { delete _perfResult[s]; delete _perfStart[s] })
  if (perfBadge) { perfBadge.textContent = '—'; perfBadge.className = 'badge' }
  if (perfDetail) perfDetail.textContent = ''
  updateRuntimeLog()
}
// ---------------------------------------------------------------------------
const countySummaryInFlight = new Set()
let countySummaryPrefetchToken = 0
let countyPickerRenderTimer = null
const US_REGION_CODE = 'US'
const UI_FAILSAFE_TIMEOUT_MS = 22000
let uiFailsafeTimer = null
let lastMapLoadingMessage = 'Loading map…'
const mapLoadState = {
  location: false,
  activeCounty: false,
  stateMask: false,
  observations: false,
}

const LOWER_48_STATES = [
  { code: 'US-AL', name: 'Alabama' },
  { code: 'US-AZ', name: 'Arizona' },
  { code: 'US-AR', name: 'Arkansas' },
  { code: 'US-CA', name: 'California' },
  { code: 'US-CO', name: 'Colorado' },
  { code: 'US-CT', name: 'Connecticut' },
  { code: 'US-DE', name: 'Delaware' },
  { code: 'US-FL', name: 'Florida' },
  { code: 'US-GA', name: 'Georgia' },
  { code: 'US-ID', name: 'Idaho' },
  { code: 'US-IL', name: 'Illinois' },
  { code: 'US-IN', name: 'Indiana' },
  { code: 'US-IA', name: 'Iowa' },
  { code: 'US-KS', name: 'Kansas' },
  { code: 'US-KY', name: 'Kentucky' },
  { code: 'US-LA', name: 'Louisiana' },
  { code: 'US-ME', name: 'Maine' },
  { code: 'US-MD', name: 'Maryland' },
  { code: 'US-MA', name: 'Massachusetts' },
  { code: 'US-MI', name: 'Michigan' },
  { code: 'US-MN', name: 'Minnesota' },
  { code: 'US-MS', name: 'Mississippi' },
  { code: 'US-MO', name: 'Missouri' },
  { code: 'US-MT', name: 'Montana' },
  { code: 'US-NE', name: 'Nebraska' },
  { code: 'US-NV', name: 'Nevada' },
  { code: 'US-NH', name: 'New Hampshire' },
  { code: 'US-NJ', name: 'New Jersey' },
  { code: 'US-NM', name: 'New Mexico' },
  { code: 'US-NY', name: 'New York' },
  { code: 'US-NC', name: 'North Carolina' },
  { code: 'US-ND', name: 'North Dakota' },
  { code: 'US-OH', name: 'Ohio' },
  { code: 'US-OK', name: 'Oklahoma' },
  { code: 'US-OR', name: 'Oregon' },
  { code: 'US-PA', name: 'Pennsylvania' },
  { code: 'US-RI', name: 'Rhode Island' },
  { code: 'US-SC', name: 'South Carolina' },
  { code: 'US-SD', name: 'South Dakota' },
  { code: 'US-TN', name: 'Tennessee' },
  { code: 'US-TX', name: 'Texas' },
  { code: 'US-UT', name: 'Utah' },
  { code: 'US-VT', name: 'Vermont' },
  { code: 'US-VA', name: 'Virginia' },
  { code: 'US-WA', name: 'Washington' },
  { code: 'US-WV', name: 'West Virginia' },
  { code: 'US-WI', name: 'Wisconsin' },
  { code: 'US-WY', name: 'Wyoming' },
]

function clearUiFailsafeTimer() {
  if (uiFailsafeTimer) {
    window.clearTimeout(uiFailsafeTimer)
    uiFailsafeTimer = null
  }
}

function restoreFromRecoverySnapshot(reason = 'failsafe') {
  const recovery = getRecoverySnapshot(currentCountyRegion || currentActiveCountyCode || null)
  if (!recovery || !Array.isArray(recovery.observations) || recovery.observations.length === 0) return false
  currentRawObservations = recovery.observations.slice()
  currentCountyName = recovery.countyName || currentCountyName || null
  currentCountyRegion = recovery.countyRegion || currentCountyRegion || null
  currentActiveCountyCode = String(recovery.activeCountyCode || currentActiveCountyCode || '').toUpperCase()
  const filtered = applyActiveFiltersAndRender({ renderMap: true, fitToObservations: false })
  if (notableMeta) notableMeta.textContent = `${notableMeta.textContent || ''} · ${reason}-recovered`
  setTableRenderStatus(`recovery-${reason} rows=${filtered.length}`)
  return true
}

function armUiFailsafeTimer() {
  clearUiFailsafeTimer()
  uiFailsafeTimer = window.setTimeout(() => {
    uiFailsafeTimer = null
    const loadingCount = notableCount?.textContent || ''
    const appearsStuck = mapLoading?.classList?.contains('visible') || loadingCount === 'Loading…' || loadingCount === 'Refreshing…'
    if (!appearsStuck) return

    console.warn('[failsafe] UI loading watchdog fired:', lastMapLoadingMessage)
    mapLoadState.location = true
    mapLoadState.activeCounty = true
    mapLoadState.stateMask = true
    mapLoadState.observations = true
    setMapLoading(false)

    if (!restoreFromRecoverySnapshot('watchdog')) {
      if (notableCount) {
        notableCount.className = 'badge warn'
        notableCount.textContent = '0'
      }
      if (notableMeta) notableMeta.textContent = 'Recovered from a stuck loading state'
      if (notableRows) notableRows.innerHTML = '<tr><td colspan="7">A stuck loading operation was reset. Try your action again.</td></tr>'
      updateStatPills('0', '0', '0')
      setTableRenderStatus('failsafe-watchdog-reset')
    }
    updateRuntimeLog()
  }, UI_FAILSAFE_TIMEOUT_MS)
}

function setMapLoading(visible, text = 'Loading map…') {
  if (visible) {
    lastMapLoadingMessage = text || 'Loading map…'
    mapLoading.classList.add('visible')
    mapLoadingText.textContent = text
    armUiFailsafeTimer()
  } else {
    mapLoading.classList.remove('visible')
    clearUiFailsafeTimer()
  }
}

function resetMapLoadState() {
  mapLoadState.location = false
  mapLoadState.activeCounty = false
  mapLoadState.stateMask = false
  mapLoadState.observations = false
  perfReset()
  setMapLoading(true, 'Loading map…')
}

function markMapPartReady(part) {
  mapLoadState[part] = true
  if (mapLoadState.location && mapLoadState.activeCounty && mapLoadState.stateMask && mapLoadState.observations) {
    setMapLoading(false)
  }
}

function handleUnhandledUiFault(source, error) {
  console.error(`[ui-failsafe] ${source}:`, error)
  mapLoadState.location = true
  mapLoadState.activeCounty = true
  mapLoadState.stateMask = true
  mapLoadState.observations = true
  setMapLoading(false)
  restoreFromRecoverySnapshot(source)
  updateRuntimeLog()
}

function rememberLastGoodObservations(observations, countyName, countyRegion, activeCountyCode) {
  if (!Array.isArray(observations) || observations.length === 0) return
  const payload = {
    observations: observations.slice(),
    countyName: countyName || null,
    countyRegion: countyRegion || null,
    activeCountyCode: String(activeCountyCode || countyRegion || '').toUpperCase(),
    timestamp: Date.now(),
  }
  lastGoodObservationSnapshot = payload
  const regionKey = String(payload.countyRegion || payload.activeCountyCode || '').toUpperCase()
  if (regionKey) lastGoodObservationsByRegion.set(regionKey, payload)
}

function getRecoverySnapshot(targetCountyRegion = null) {
  const regionKey = String(targetCountyRegion || '').toUpperCase()
  if (regionKey && lastGoodObservationsByRegion.has(regionKey)) {
    return lastGoodObservationsByRegion.get(regionKey)
  }
  return lastGoodObservationSnapshot
}

function nextAnimationFrame() {
  return new Promise((resolve) => window.requestAnimationFrame(() => resolve()))
}

function isStaleLocationRequest(requestId) {
  return requestId !== latestLocationRequestId
}

function isStaleCountySwitchRequest(requestId) {
  return requestId !== latestCountySwitchRequestId
}

function isStaleNotablesLoad(loadId, requestId, countySwitchRequestId = null) {
  if (loadId !== latestNotablesLoadId) return true
  if (requestId !== null && isStaleLocationRequest(requestId)) return true
  if (countySwitchRequestId !== null && isStaleCountySwitchRequest(countySwitchRequestId)) return true
  return false
}

function cutoffDateForDaysBack(daysBack) {
  const days = Math.max(1, Number(daysBack) || 1)
  const cutoff = new Date()
  cutoff.setHours(0, 0, 0, 0)
  cutoff.setDate(cutoff.getDate() - (days - 1))
  return cutoff
}

function getAbaCodeNumber(item) {
  const rawCode = item?.abaCode ?? item?.abaRarityCode
  const code = Number(rawCode)
  if (Number.isFinite(code)) {
    const rounded = Math.round(code)
    if (rounded >= 1 && rounded <= 6) return rounded
  }
  const overrideCode = getAbaCodeOverride(
    item?.comName || item?.species || '',
    item?.speciesCode || item?.species_code || item?.speciesCode4 || ''
  )
  return Number.isFinite(Number(overrideCode)) ? Math.round(Number(overrideCode)) : null
}

function matchesAbaSelection(item, abaMinValue, selectedCodes) {
  const code = getAbaCodeNumber(item)
  const selected = selectedCodes instanceof Set ? selectedCodes : new Set()
  const hasSelections = selected.size > 0
  if (hasSelections) {
    if (selected.has(0)) {
      return !Number.isFinite(code)
    }
    return Number.isFinite(code) && selected.has(code)
  }
  if (!Number.isFinite(code)) return false
  const minCode = Math.max(1, Number(abaMinValue) || 1)
  return code >= minCode
}

function applyActiveFiltersAndRender(options = {}) {
  const { renderMap = true, fitToObservations = false, allowAutoRecovery = true } = options
  const source = Array.isArray(currentRawObservations) ? currentRawObservations : []
  const cutoff = cutoffDateForDaysBack(filterDaysBack)
  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  const abaFloor = activeRegion === US_REGION_CODE ? 3 : 1
  const abaMin = Math.max(abaFloor, Number(filterAbaMin) || abaFloor)
  if (filterAbaMin !== abaMin) {
    filterAbaMin = abaMin
    if (filterAbaMinInput) filterAbaMinInput.value = String(filterAbaMin)
  }
  const filteredByDays = source.filter((item) => {
    const obsDate = parseObsDate(item?.obsDt)
    if (!obsDate || obsDate < cutoff) return false
    return true
  })
  updateAbaCodePickerOptions(filteredByDays)
  const filteredByStatus = filteredByDays.filter((item) => {
    if (selectedReviewFilter === 'confirmed') return isConfirmedObservation(item)
    if (selectedReviewFilter === 'pending') return !isConfirmedObservation(item)
    return true
  })
  const filteredBySpecies = selectedSpecies
    ? filteredByStatus.filter((item) => String(item?.comName || '') === selectedSpecies)
    : filteredByStatus

  const activeCountyCode = String(currentActiveCountyCode || '').toUpperCase()
  const isStateMode = /^US-[A-Z]{2}$/.test(activeRegion) && !isCountyRegionCode(activeCountyCode) && activeRegion !== US_REGION_CODE
  const isNationalSummaryMode = activeRegion === US_REGION_CODE

  // State mode shows the full state's dataset; distance is used for sorting
  // (in the table renderer), not for filtering.
  const pillObservationSource = filteredBySpecies

  const filtered = pillObservationSource.filter((item) => matchesAbaSelection(item, abaMin, selectedAbaCodes))

  if (allowAutoRecovery && filtered.length === 0 && filteredByDays.length > 0) {
    let recovered = false
    if (selectedSpecies && filteredByStatus.length > 0) {
      selectedSpecies = null
      recovered = true
    } else if (selectedReviewFilter) {
      selectedReviewFilter = null
      recovered = true
    }

    if (recovered) {
      updateFilterUi()
      return applyActiveFiltersAndRender({ renderMap, fitToObservations, allowAutoRecovery: false })
    }
  }

  // ABA pills should reflect the current view's dataset before ABA filtering.
  const abaPillSource = pillObservationSource
  refreshSearchSpeciesOptions(filteredByDays)
  renderNotableTable(filtered, currentCountyName, currentCountyRegion, abaPillSource)
  if (renderMap) {
    renderNotablesOnMap(
      isNationalSummaryMode ? [] : filtered,
      (currentActiveCountyCode || currentCountyRegion || '').toUpperCase(),
      fitToObservations
    )
  }
  syncFilterPillUi()
  return filtered
}

function setPillExpandedLabel(pill, prefix) {
  if (!pill) return
  if (!pill.dataset.short || pill.textContent.includes(':')) {
    pill.dataset.short = pill.textContent.replace(/^.*?:\s*/, '').trim()
  }
  pill.textContent = `${prefix}: ${pill.dataset.short}`
  pill.classList.add('obs-stat-expanded')
}

function syncFilterPillUi() {
  const abaPills = document.querySelectorAll('#topAbaPills .stat-aba-pill, .picker-aba-pills .stat-aba-pill')
  abaPills.forEach((pill) => {
    const code = Number(pill.dataset.code)
    const isActive = Number.isFinite(code) && selectedAbaCodes instanceof Set && selectedAbaCodes.has(code)
    pill.classList.toggle('is-active', isActive)
    pill.setAttribute('aria-pressed', String(isActive))
  })
}

function updateFilterUi() {
  if (filterDaysBackValue) filterDaysBackValue.textContent = String(filterDaysBack)
  if (filterAbaMinValue) filterAbaMinValue.textContent = String(filterAbaMin)
  if (headerDaysBackSelect && headerDaysBackSelect.value !== String(filterDaysBack)) headerDaysBackSelect.value = String(filterDaysBack)
  if (searchDaysBackInput) searchDaysBackInput.value = String(filterDaysBack)
  if (searchDaysBackValue) searchDaysBackValue.textContent = String(filterDaysBack)
  if (searchAbaMinInput) searchAbaMinInput.value = String(filterAbaMin)
  if (searchAbaMinValue) searchAbaMinValue.textContent = String(filterAbaMin)
}

function getEffectiveSearchAbaMin(regionCode, requestedAbaMin) {
  const normalizedRegion = String(regionCode || '').toUpperCase()
  const requested = Math.max(1, Math.min(6, Number(requestedAbaMin) || 1))
  if (normalizedRegion === US_REGION_CODE) return Math.max(3, requested)
  return requested
}

function syncSearchSlidersForRegion(regionCode) {
  if (!searchAbaMinInput || !searchAbaMinValue || !searchDaysBackInput || !searchDaysBackValue) return
  const normalizedRegion = String(regionCode || '').toUpperCase()
  const isUsRegion = normalizedRegion === US_REGION_CODE

  searchAbaMinInput.min = isUsRegion ? '3' : '1'
  const currentAba = Number(searchAbaMinInput.value || filterAbaMin || 1)
  const effectiveAba = getEffectiveSearchAbaMin(normalizedRegion, currentAba)
  searchAbaMinInput.value = String(effectiveAba)
  searchAbaMinValue.textContent = String(effectiveAba)

  const days = Math.max(1, Math.min(14, Number(searchDaysBackInput.value || filterDaysBack || 7)))
  searchDaysBackInput.value = String(days)
  searchDaysBackValue.textContent = String(days)
}

function closeCountyPicker() {
  if (!countyPicker) return
  countyPicker.setAttribute('hidden', 'hidden')
}

function closeAbaCodePicker() {
  if (!abaCodePicker) return
  abaCodePicker.setAttribute('hidden', 'hidden')
}

function toggleCountyPicker() {
  if (!countyPicker || !countyPickerList) return
  closeStatePicker()
  closeAbaCodePicker()
  if (countyPicker.hasAttribute('hidden')) countyPicker.removeAttribute('hidden')
  else countyPicker.setAttribute('hidden', 'hidden')
}

function toggleAbaCodePicker() {
  if (!abaCodePicker || !abaCodePickerList) return
  closeCountyPicker()
  if (abaCodePicker.hasAttribute('hidden')) abaCodePicker.removeAttribute('hidden')
  else abaCodePicker.setAttribute('hidden', 'hidden')
}

function updateAbaCodePickerOptions(source) {
  if (!abaCodePickerList) return
  const counts = new Map([[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0]])
  ;(Array.isArray(source) ? source : []).forEach((item) => {
    const code = getAbaCodeNumber(item)
    if (Number.isFinite(code) && code >= 1 && code <= 6) counts.set(code, (counts.get(code) || 0) + 1)
    else counts.set(0, (counts.get(0) || 0) + 1)
  })
  const allCount = Array.from(counts.values()).reduce((sum, val) => sum + val, 0)
  abaCodePickerOptions = [{ value: 'all', label: `Show all codes · ${allCount}` }]
  for (let code = 1; code <= 6; code += 1) {
    abaCodePickerOptions.push({ value: String(code), label: `ABA ${code} · ${counts.get(code) || 0}` })
  }
  abaCodePickerOptions.push({ value: '0', label: `ABA 0 (none) · ${counts.get(0) || 0}` })
  abaCodePickerList.innerHTML = abaCodePickerOptions
    .map((opt, index) => {
      const parsed = Number(opt.value)
      const isAll = opt.value === 'all'
      const isActive = isAll
        ? (selectedAbaCodes.size === 0)
        : (Number.isFinite(parsed) && selectedAbaCodes.has(Math.round(parsed)))
      return `<button type="button" class="county-option${isActive ? ' is-active' : ''}" data-index="${index}" role="option" aria-selected="${isActive ? 'true' : 'false'}">${escapeHtml(opt.label)}</button>`
    })
    .join('')
}

function buildCountyGeojsonWithActiveRegion(sourceGeojson, countyRegion) {
  if (!sourceGeojson || !Array.isArray(sourceGeojson.features) || !countyRegion) return null
  const targetRegion = String(countyRegion).toUpperCase()
  let found = false
  const features = sourceGeojson.features.map((feature) => {
    const regionRaw = feature?.properties?.countyRegion || feature?.properties?.subnational2Code || null
    const region = regionRaw ? String(regionRaw).toUpperCase() : null
    const isActive = region === targetRegion
    if (isActive) found = true
    return {
      ...feature,
      properties: {
        ...(feature?.properties || {}),
        countyRegion: region || null,
        isActiveCounty: isActive,
      },
    }
  })
  if (!found) return null
  return {
    ...sourceGeojson,
    inverseMaskFeatures: undefined,
    activeLabel: undefined,
    activeCountyRegion: targetRegion,
    features,
  }
}

function getFeatureCenter(feature) {
  try {
    const layer = L.geoJSON(feature)
    const bounds = layer.getBounds()
    if (!bounds.isValid()) return null
    return bounds.getCenter()
  } catch {
    return null
  }
}

function pointInRing(lng, lat, ring) {
  let inside = false
  for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    const xi = Number(ring[i]?.[0])
    const yi = Number(ring[i]?.[1])
    const xj = Number(ring[j]?.[0])
    const yj = Number(ring[j]?.[1])
    if (!Number.isFinite(xi) || !Number.isFinite(yi) || !Number.isFinite(xj) || !Number.isFinite(yj)) continue
    const intersects = ((yi > lat) !== (yj > lat)) && (lng < ((xj - xi) * (lat - yi)) / ((yj - yi) || 1e-12) + xi)
    if (intersects) inside = !inside
  }
  return inside
}

function pointInPolygon(lng, lat, polygonCoords) {
  if (!Array.isArray(polygonCoords) || polygonCoords.length === 0) return false
  const outer = polygonCoords[0]
  if (!Array.isArray(outer) || outer.length < 3) return false
  if (!pointInRing(lng, lat, outer)) return false
  for (let index = 1; index < polygonCoords.length; index += 1) {
    const hole = polygonCoords[index]
    if (Array.isArray(hole) && hole.length >= 3 && pointInRing(lng, lat, hole)) {
      return false
    }
  }
  return true
}

function featureContainsPoint(feature, lng, lat) {
  const geometry = feature?.geometry
  if (!geometry) return false
  if (geometry.type === 'Polygon') {
    return pointInPolygon(lng, lat, geometry.coordinates)
  }
  if (geometry.type === 'MultiPolygon') {
    return Array.isArray(geometry.coordinates)
      && geometry.coordinates.some((polygonCoords) => pointInPolygon(lng, lat, polygonCoords))
  }
  return false
}

function findNeighborCountyFeatureAtLatLng(lat, lng) {
  const features = Array.isArray(latestCountyContextGeojson?.features) ? latestCountyContextGeojson.features : []
  for (const feature of features) {
    if (feature?.properties?.isActiveCounty) continue
    if (featureContainsPoint(feature, lng, lat)) return feature
  }
  return null
}

function zoomToActiveCounty(geojson, countyRegion = null) {
  if (!map || !geojson || !Array.isArray(geojson.features)) return false
  const targetRegion = String(countyRegion || '').toUpperCase()
  const activeFeatures = geojson.features.filter((feature) => {
    if (feature?.properties?.isActiveCounty) return true
    if (!targetRegion) return false
    return String(feature?.properties?.countyRegion || '').toUpperCase() === targetRegion
  })
  if (!activeFeatures.length) return false
  try {
    const bounds = L.geoJSON({ type: 'FeatureCollection', features: activeFeatures }).getBounds()
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [22, 22], maxZoom: 11, animate: true })
      return true
    }
  } catch {
    // ignore zoom errors
  }
  return false
}

function zoomToStateBounds(geojson, stateRegion) {
  if (!map || !geojson || !Array.isArray(geojson.features)) return false
  const normalizedState = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(normalizedState)) return false
  const prefix = `${normalizedState}-`
  const stateFeatures = geojson.features.filter((feature) => {
    const countyRegion = String(feature?.properties?.countyRegion || feature?.properties?.subnational2Code || '').toUpperCase()
    return countyRegion.startsWith(prefix)
  })
  if (!stateFeatures.length) return false
  try {
    const bounds = L.geoJSON({ type: 'FeatureCollection', features: stateFeatures }).getBounds()
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [24, 24], maxZoom: 7, animate: true })
      return true
    }
  } catch {
    // ignore zoom errors
  }
  return false
}

function distanceKm(lat1, lng1, lat2, lng2) {
  const toRad = (value) => (value * Math.PI) / 180
  const dLat = toRad(lat2 - lat1)
  const dLng = toRad(lng2 - lng1)
  const a = Math.sin(dLat / 2) ** 2
    + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2
  return 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
}

function filterObservationsToCountyRegion(observations, countyRegion) {
  const target = String(countyRegion || '').toUpperCase()
  const source = Array.isArray(observations) ? observations : []
  if (!target) return source
  return source.filter((item) => String(item?.subnational2Code || '').toUpperCase() === target)
}

function filterObservationsToStateRegion(observations, stateRegion) {
  const target = String(stateRegion || '').toUpperCase()
  const source = Array.isArray(observations) ? observations : []
  if (!/^US-[A-Z]{2}$/.test(target)) return source
  return source.filter((item) => String(item?.subnational1Code || '').toUpperCase() === target)
}

function summarizeCountyObservations(observations) {
  const grouped = new Map()
  ;(Array.isArray(observations) ? observations : []).forEach((item) => {
    const species = item?.comName || ''
    const state = String(item?.subnational1Code || '')
    const county = String(item?.subnational2Code || item?.subnational2Name || '')
    const key = `${species}::${state}::${county}`
    const abaCode = getAbaCodeNumber(item)
    if (!grouped.has(key)) {
      grouped.set(key, { abaCode })
      return
    }
    const existing = grouped.get(key)
    if (abaCode > existing.abaCode) existing.abaCode = abaCode
  })

  const abaCounts = new Map([[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0]])
  grouped.forEach((entry) => {
    const code = Number.isFinite(entry.abaCode) && entry.abaCode >= 1 && entry.abaCode <= 6 ? entry.abaCode : 0
    abaCounts.set(code, (abaCounts.get(code) || 0) + 1)
  })

  return {
    rarityCount: grouped.size,
    abaCounts,
  }
}

function formatCountySummary(summary) {
  if (!summary) return 'Rarities: — · ABA: —'
  const parts = []
  for (let code = 1; code <= 6; code += 1) {
    const count = summary.abaCounts.get(code) || 0
    if (count > 0) parts.push(`${code}:${count}`)
  }
  const none = summary.abaCounts.get(0) || 0
  if (none > 0) parts.push(`0:${none}`)
  const abaText = parts.length ? parts.join(' ') : 'none'
  return `Rarities: ${summary.rarityCount} · ABA ${abaText}`
}

function formatCountySummaryPills(summary) {
  if (!summary) return ''
  const pills = [`<span class="county-pill county-pill-rarity" title="Total rarities">${summary.rarityCount}</span>`]
  for (let code = 1; code <= 6; code += 1) {
    const count = summary.abaCounts.get(code) || 0
    if (count > 0) {
      pills.push(`<span class="county-pill county-aba-pill aba-code-${code}" title="ABA ${code}: ${count}">${count}</span>`)
    }
  }
  return pills.join('')
}

function scheduleCountyPickerRender() {
  if (countyPickerRenderTimer) return
  countyPickerRenderTimer = window.setTimeout(() => {
    countyPickerRenderTimer = null
    renderCountyPickerOptions()
    updateCountyDots()
  }, 50)
}

function getCountySummary(region, isActive) {
  if (isActive) {
    const activeSummary = summarizeCountyObservations(currentRawObservations)
    if (region) countySummaryByRegion.set(region, activeSummary)
    return activeSummary
  }
  if (region && countySummaryByRegion.has(region)) {
    return countySummaryByRegion.get(region) || null
  }
  const cached = loadNotablesCache(region)
  if (!cached || !Array.isArray(cached.observations) || cached.observations.length === 0) return null
  const summary = summarizeCountyObservations(filterObservationsToCountyRegion(cached.observations, region))
  if (region) countySummaryByRegion.set(region, summary)
  return summary
}

function getStateSummary(stateRegion, isActive) {
  const region = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(region)) return null

  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  const canDeriveFromCurrent = activeRegion === region || activeRegion === US_REGION_CODE

  if (canDeriveFromCurrent && Array.isArray(currentRawObservations) && currentRawObservations.length) {
    const scoped = activeRegion === US_REGION_CODE
      ? filterObservationsToStateRegion(currentRawObservations, region)
      : currentRawObservations
    const summary = summarizeCountyObservations(scoped)
    stateSummaryByRegion.set(region, summary)
    return summary
  }

  if (region && stateSummaryByRegion.has(region)) {
    return stateSummaryByRegion.get(region) || null
  }

  const cached = loadNotablesCache(region)
  if (!cached || !Array.isArray(cached.observations) || cached.observations.length === 0) return null
  const summary = summarizeCountyObservations(cached.observations)
  stateSummaryByRegion.set(region, summary)
  return summary
}

function renderCountyPickerOptions() {
  if (!countyPickerList) return
  countyPickerList.innerHTML = countyPickerOptions
    .map((opt, index) => {
      const activeClass = opt.isActive ? ' is-active' : ''
      const summary = getCountySummary(opt.countyRegion, opt.isActive)
      const pillsHtml = formatCountySummaryPills(summary)
      return `<button type="button" class="county-option${activeClass}" data-index="${index}" role="option" aria-selected="${opt.isActive ? 'true' : 'false'}"><span class="county-option-name">${escapeHtml(opt.countyName)}</span><span class="county-option-meta county-option-meta-pills">${pillsHtml}</span></button>`
    })
    .join('')
}

// ABA dot colors matching canvas overlay palette
const DOT_ABA_COLORS = {
  1: '#067bc2', 2: '#84bcda', 3: '#ecc30b', 4: '#f37748', 5: '#ED1313', 6: '#ed13d4',
}

function updateCountyDots() {
  if (!map || !countyPickerOptions.length) return
  const showCountyNames = map.getZoom() > 10

  if (!countyDotLayerRef) {
    countyDotLayerRef = L.layerGroup({ pane: 'countyDotPane' }).addTo(map)
  }
  countyDotLayerRef.clearLayers()

  for (const opt of countyPickerOptions) {
    if (opt.isActive) continue
    if (!opt.countyRegion || !Number.isFinite(opt.lat) || !Number.isFinite(opt.lng)) continue

    const summary = getCountySummary(opt.countyRegion, false)
    const rarityCount = summary?.rarityCount || 0

    // Pick color from highest ABA code present
    let dotColor = '#64748b'
    if (summary) {
      for (let code = 6; code >= 1; code--) {
        if ((summary.abaCounts.get(code) || 0) > 0) { dotColor = DOT_ABA_COLORS[code]; break }
      }
    }

    const countText = rarityCount > 0 ? String(rarityCount) : ''
    const markerHtml = `
      <div class="county-dot-marker">
        ${showCountyNames ? `<span class="cdot-name">${escapeHtml(opt.countyName)}</span>` : ''}
        <span class="cdot-circle" style="background:${dotColor}">${countText}</span>
      </div>
    `

    const iconSize = showCountyNames ? [88, 38] : [28, 28]
    const iconAnchor = showCountyNames ? [44, 22] : [14, 14]

    const dot = L.marker([opt.lat, opt.lng], {
      pane: 'countyDotPane',
      icon: L.divIcon({
        className: 'county-dot-icon',
        html: markerHtml,
        iconSize,
        iconAnchor,
      }),
      interactive: true,
    })

    dot.on('click', (e) => {
      if (e?.originalEvent) {
        L.DomEvent.stopPropagation(e.originalEvent)
        L.DomEvent.preventDefault(e.originalEvent)
      }
      switchCountyFromMapTap(opt.countyRegion, opt.lat, opt.lng, opt.countyName, 'county-dot')
    })

    countyDotLayerRef.addLayer(dot)
  }
}

async function prefetchCountySummariesForPicker(options) {
  if (!Array.isArray(options) || options.length === 0) return
  if (!Number.isFinite(lastUserLat) || !Number.isFinite(lastUserLng)) return

  const token = ++countySummaryPrefetchToken
  const targets = options.filter((opt) => opt?.countyRegion && !opt.isActive)
  let pointer = 0
  const workers = Math.min(3, targets.length)

  const runWorker = async () => {
    while (pointer < targets.length) {
      if (token !== countySummaryPrefetchToken) return
      const currentIndex = pointer
      pointer += 1
      const region = targets[currentIndex]?.countyRegion
      if (!region || countySummaryByRegion.has(region) || countySummaryInFlight.has(region)) continue

      countySummaryInFlight.add(region)
      try {
        const cached = loadNotablesCache(region)
        if (Array.isArray(cached?.observations) && cached.observations.length > 0) {
          const scoped = filterObservationsToCountyRegion(cached.observations, region)
          countySummaryByRegion.set(region, summarizeCountyObservations(scoped))
          scheduleCountyPickerRender()
          // Also pre-warm hi-res boundary for this neighbor
          void fetchCountyHiRes(region).catch(() => {})
          continue
        }

        const result = await fetchCountyNotablesWithRetry(lastUserLat, lastUserLng, 14, region, 1)
        if (!Array.isArray(result?.observations) || result.observations.length === 0) continue
        saveNotablesCache(region, result)
        const scoped = filterObservationsToCountyRegion(result.observations, region)
        countySummaryByRegion.set(region, summarizeCountyObservations(scoped))
        scheduleCountyPickerRender()
        // Pre-warm hi-res boundary for this neighbor
        void fetchCountyHiRes(region).catch(() => {})
      } catch {
        // ignore county summary prefetch failures
      } finally {
        countySummaryInFlight.delete(region)
      }
    }
  }

  await Promise.all(Array.from({ length: workers }, () => runWorker()))
}

function refreshCountyPickerSummaries() {
  if (!latestCountyContextGeojson) return
  updateCountyPickerFromGeojson(latestCountyContextGeojson)
}

function renderInfoTechMetrics() {
  if (!infoTechMetrics) return
  const activeRegion = String(currentActiveCountyCode || currentCountyRegion || '').toUpperCase() || '—'
  const abaSel = (selectedAbaCodes instanceof Set && selectedAbaCodes.size > 0)
    ? Array.from(selectedAbaCodes).sort((a, b) => a - b).join(',')
    : 'all'
  const activeFiltersSummary = `days=${filterDaysBack} species=${selectedSpecies || 'all'} abaMin=${filterAbaMin} aba=${abaSel} review=${selectedReviewFilter || 'all'}`
  const lines = [
    `Build: ${BUILD_TAG}`,
    `API: ${apiStatus?.textContent || '—'}`,
    `API Detail: ${apiDetail?.textContent || '—'}`,
    `Location: ${locationStatus?.textContent || '—'}`,
    `Location Detail: ${locationDetail?.textContent || '—'}`,
    `County: ${currentCountyName || '—'}${currentCountyRegion ? ` (${currentCountyRegion})` : ''}`,
    `Active County + Filters: ${activeRegion} | ${activeFiltersSummary}`,
    'Load Times:',
    perfDetail?.textContent ? perfDetail.textContent : '—',
  ]
  infoTechMetrics.textContent = lines.join('\n')
}

function saveTapDebugEnabled(value) {
  try {
    localStorage.setItem(TAP_DEBUG_STORAGE_KEY, value ? '1' : '0')
  } catch {
    // ignore storage failures
  }
}

function loadTapDebugEnabled() {
  try {
    return localStorage.getItem(TAP_DEBUG_STORAGE_KEY) === '1'
  } catch {
    return false
  }
}

function renderTapDebugLog() {
  if (!tapDebugLog) return
  if (!tapDebugEnabled) {
    tapDebugLog.textContent = 'Debug disabled'
    return
  }
  tapDebugLog.textContent = tapDebugEvents.length ? tapDebugEvents.join('\n') : 'No tap events yet'
}

function formatTapDebugCoord(value) {
  const numeric = Number(value)
  return Number.isFinite(numeric) ? numeric.toFixed(5) : '—'
}

function logTapResolution(stage, payload = {}) {
  if (!tapDebugEnabled) return
  const source = String(payload.source || 'map')
  const region = String(payload.region || '').toUpperCase() || '—'
  const name = String(payload.name || '') || '—'
  const lat = formatTapDebugCoord(payload.lat)
  const lng = formatTapDebugCoord(payload.lng)
  const detail = String(payload.detail || '')
  const stamp = new Date().toISOString().slice(11, 19)
  const line = `[${stamp}] ${stage} src=${source} region=${region} name=${name} lat=${lat} lng=${lng}${detail ? ` detail=${detail}` : ''}`
  tapDebugEvents.unshift(line)
  if (tapDebugEvents.length > TAP_DEBUG_MAX_ENTRIES) {
    tapDebugEvents.length = TAP_DEBUG_MAX_ENTRIES
  }
  renderTapDebugLog()
}

function updateRuntimeLog() {
  renderInfoTechMetrics()
  try {
    localStorage.setItem('mrm_runtime_log', JSON.stringify({
      timestamp: new Date().toISOString(),
      buildTag: BUILD_TAG,
      apiStatus: apiStatus?.textContent || '',
      apiDetail: apiDetail?.textContent || '',
      locationStatus: locationStatus?.textContent || '',
      locationDetail: locationDetail?.textContent || '',
      county: currentCountyName || '',
      countyRegion: currentCountyRegion || '',
      filters: {
        daysBack: filterDaysBack,
        abaMin: filterAbaMin,
        species: selectedSpecies,
      },
      perf: perfDetail?.textContent || '',
    }))
  } catch {
    // ignore storage failures
  }
}

function refreshHeaderCountyOptions() {
  if (!headerCountySelect) return
  const options = countyPickerOptions
  if (!Array.isArray(options) || options.length === 0) {
    headerCountySelect.innerHTML = ''
    const loadingOption = document.createElement('option')
    loadingOption.value = ''
    loadingOption.textContent = 'Loading…'
    headerCountySelect.appendChild(loadingOption)
    if (headerCountyBtn) headerCountyBtn.textContent = 'Loading…'
    return
  }
  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  const isStateOrUsContext = activeRegion === US_REGION_CODE || /^US-[A-Z]{2}$/.test(activeRegion)
  headerCountySelect.innerHTML = ''

  // In state/US context there is no active county; keep header as "Select County".
  if (isStateOrUsContext) {
    const placeholder = document.createElement('option')
    placeholder.value = ''
    placeholder.textContent = 'Select County'
    headerCountySelect.appendChild(placeholder)
  }

  options.forEach((opt, index) => {
    const optionEl = document.createElement('option')
    optionEl.value = String(opt.countyRegion || '')
    const name = String(opt.countyName || 'Unknown county')
    const region = String(opt.countyRegion || '').toUpperCase()
    const isActive = region === activeRegion || Boolean(opt.isActive)
    if (isActive) {
      // Keep the header "pill" clean: no ABA counts on the selected value.
      optionEl.textContent = name
    } else {
      const summary = getCountySummary(region, false)
      const parts = []
      if (summary && summary.abaCounts instanceof Map) {
        for (let code = 6; code >= 1; code -= 1) {
          const count = summary.abaCounts.get(code) || 0
          if (count > 0) parts.push(`${code}:${count}`)
        }
      }
      const meta = summary ? ` · ${summary.rarityCount}${parts.length ? ` · ${parts.join(' ')}` : ''}` : ''
      optionEl.textContent = `${name}${meta}`
    }
    optionEl.dataset.index = String(index)
    headerCountySelect.appendChild(optionEl)
  })
  const selectedIndex = options.findIndex((opt) => String(opt.countyRegion || '').toUpperCase() === activeRegion)
  if (selectedIndex >= 0) {
    headerCountySelect.selectedIndex = isStateOrUsContext ? (1 + selectedIndex) : selectedIndex
  } else {
    headerCountySelect.selectedIndex = 0
  }

  if (headerCountyBtn) {
    const selectedOpt = headerCountySelect.selectedOptions?.[0]
    headerCountyBtn.textContent = selectedOpt?.textContent || String(options[headerCountySelect.selectedIndex]?.countyName || 'County')
  }
}

function stateRegionFromAnyRegion(regionCode) {
  const normalized = String(regionCode || '').toUpperCase()
  if (normalized === US_REGION_CODE) return US_REGION_CODE
  if (/^US-[A-Z]{2}$/.test(normalized)) return normalized
  if (/^US-[A-Z]{2}-\d{3}$/.test(normalized)) return stateRegionFromCountyRegion(normalized)
  return null
}

function getStateAbbrevByRegion(regionCode) {
  const normalized = String(regionCode || '').toUpperCase()
  if (normalized === US_REGION_CODE) return 'US'
  if (/^US-[A-Z]{2}$/.test(normalized)) return normalized.split('-')[1] || normalized
  return normalized
}

function refreshHeaderStateOptions() {
  if (!headerStateSelect || !headerStateBtn) return
  const activeState = stateRegionFromAnyRegion(currentCountyRegion) || 'US-CA'
  const options = LOWER_48_STATES

  headerStateSelect.innerHTML = options
    .map((state) => {
      const selected = String(state.code).toUpperCase() === String(activeState).toUpperCase()
      return `<option value="${escapeHtml(state.code)}" ${selected ? 'selected' : ''}>${escapeHtml(state.name)}</option>`
    })
    .join('')

  const abbrev = getStateAbbrevByRegion(activeState)
  headerStateBtn.textContent = abbrev
  const stateObj = options.find((s) => s.code === activeState)
  headerStateBtn.title = stateObj ? stateObj.name : 'Choose state'
}

function closeStatePicker() {
  if (!statePicker) return
  statePicker.setAttribute('hidden', 'hidden')
}

function toggleStatePicker() {
  if (!statePicker || !statePickerList) return
  closeCountyPicker()
  closeAbaCodePicker()
  if (statePicker.hasAttribute('hidden')) statePicker.removeAttribute('hidden')
  else statePicker.setAttribute('hidden', 'hidden')
}

function renderStatePickerOptions() {
  if (!statePickerList) return
  const activeState = stateRegionFromAnyRegion(currentCountyRegion) || 'US-CA'
  statePickerList.innerHTML = LOWER_48_STATES
    .map((state, index) => {
      const abbrev = getStateAbbrevByRegion(state.code)
      const isActive = String(state.code).toUpperCase() === String(activeState).toUpperCase()
      const summary = getStateSummary(state.code, isActive)
      const pillsHtml = formatCountySummaryPills(summary)
      const label = `${abbrev} · ${state.name}`
      return `<button type="button" class="county-option${isActive ? ' is-active' : ''}" data-index="${index}" role="option" aria-selected="${isActive ? 'true' : 'false'}"><span class="county-option-name">${escapeHtml(label)}</span><span class="county-option-meta county-option-meta-pills">${pillsHtml}</span></button>`
    })
    .join('')
}

async function activateStateByRegion(stateRegion) {
  const normalized = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(normalized)) return
  resetFiltersForCountySwitch()
  refreshHeaderStateOptions()
  renderStatePickerOptions()
  await loadStateNotables(normalized)
  refreshHeaderStateOptions()
  renderStatePickerOptions()
  refreshHeaderCountyOptions()
}

function switchToCountyOption(option) {
  if (!option) return
  const optionRegion = String(option.countyRegion || '').toUpperCase()
  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  if (optionRegion && optionRegion === activeRegion) return
  void loadNeighborCounty(option.lat, option.lng, option.countyRegion, option.countyName)
}

function resetFiltersForCountySwitch() {
  selectedSpecies = null
  selectedReviewFilter = null
  selectedAbaCodes = new Set()
  if (!preservePinnedSpeciesOnce) {
    pinnedSpecies = null
  }
  preservePinnedSpeciesOnce = false
  updateFilterUi()
  syncFilterPillUi()
}

function switchCountyFromMapTap(countyRegion, lat = null, lng = null, countyName = '', source = 'map') {
  logTapResolution('tap-enter', {
    source,
    region: countyRegion,
    name: countyName,
    lat,
    lng,
  })

  let region = String(countyRegion || '').toUpperCase() || null
  const tapLat = Number(lat)
  const tapLng = Number(lng)

  if (!region && countyName) {
    const nameNeedle = normalizeCountyName(countyName)
    const namedOption = countyPickerOptions.find((opt) => normalizeCountyName(opt.countyName) === nameNeedle)
      || countyPickerOptions.find((opt) => {
        const optionName = normalizeCountyName(opt.countyName)
        return optionName.includes(nameNeedle) || nameNeedle.includes(optionName)
      })
      || null
    region = String(namedOption?.countyRegion || '').toUpperCase() || null
    logTapResolution('tap-name-match', {
      source,
      region,
      name: countyName,
      lat: tapLat,
      lng: tapLng,
      detail: namedOption ? 'matched picker option' : 'no picker name match',
    })
  }

  if (!region && Number.isFinite(tapLat) && Number.isFinite(tapLng)) {
    const neighborAtPoint = findNeighborCountyFeatureAtLatLng(tapLat, tapLng)
    region = String(neighborAtPoint?.properties?.countyRegion || neighborAtPoint?.properties?.subnational2Code || '').toUpperCase() || null
    if (!countyName) {
      countyName = neighborAtPoint?.properties?.countyName || neighborAtPoint?.properties?.NAME || neighborAtPoint?.properties?.name || ''
    }
    logTapResolution('tap-point-match', {
      source,
      region,
      name: countyName,
      lat: tapLat,
      lng: tapLng,
      detail: neighborAtPoint ? 'matched neighbor geometry' : 'no neighbor geometry match',
    })
  }

  if (!region) {
    logTapResolution('tap-unresolved', {
      source,
      name: countyName,
      lat: tapLat,
      lng: tapLng,
      detail: 'activating by null region fallback',
    })
    activateCountyByRegion(null, lat, lng, countyName)
    return
  }

  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  if (region === activeRegion) return

  const option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === region) || null
  const optionLat = Number(option?.lat)
  const optionLng = Number(option?.lng)
  const resolvedLat = Number.isFinite(optionLat) ? optionLat : (Number.isFinite(tapLat) ? tapLat : null)
  const resolvedLng = Number.isFinite(optionLng) ? optionLng : (Number.isFinite(tapLng) ? tapLng : null)
  const resolvedName = countyName || option?.countyName || ''
  logTapResolution('tap-resolved', {
    source,
    region,
    name: resolvedName,
    lat: resolvedLat,
    lng: resolvedLng,
    detail: option ? 'using picker option center' : 'using tap coordinates',
  })
  // Route through the same activation path as the dropdown so the header county
  // UI stays in sync.
  activateCountyByRegion(region, resolvedLat, resolvedLng, resolvedName)
}

function normalizeCountyName(value) {
  return String(value || '')
    .toLowerCase()
    .replace(/\b(county|parish|borough|census area)\b/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
}

function shortCountyName(value) {
  const raw = String(value || '').trim()
  if (!raw) return ''
  return raw
    .replace(/\s+(County|Parish|Borough|Census Area)$/i, '')
    .replace(/\s+City and Borough$/i, '')
    .replace(/\s+City$/i, '')
    .trim()
}

function activateCountyByRegion(countyRegion, lat = null, lng = null, countyName = '') {
  const region = String(countyRegion || '').toUpperCase()
  let option = null

  if (region) {
    option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === region) || null
  }

  if (!option && countyName) {
    const nameNeedle = normalizeCountyName(countyName)
    option = countyPickerOptions.find((opt) => normalizeCountyName(opt.countyName) === nameNeedle) || null
    if (!option && nameNeedle) {
      option = countyPickerOptions.find((opt) => normalizeCountyName(opt.countyName).includes(nameNeedle) || nameNeedle.includes(normalizeCountyName(opt.countyName))) || null
    }
  }

  if (!option) {
    option = {
      countyRegion: region || null,
      countyName: countyName || '',
      lat,
      lng,
      isActive: false,
    }
  }

  activateCountyFromOption(option)
}

function activateCountyFromOption(option) {
  if (!option) return
  const region = String(option.countyRegion || '').toUpperCase()
  if (!region) {
    if (Number.isFinite(Number(option.lat)) && Number.isFinite(Number(option.lng))) {
      resetFiltersForCountySwitch()
      void loadNeighborCounty(Number(option.lat), Number(option.lng), null, option.countyName || '')
    }
    return
  }

  if (headerCountySelect) {
    const headerIndex = countyPickerOptions.findIndex((opt) => String(opt.countyRegion || '').toUpperCase() === region)
    if (headerIndex >= 0) {
      const activeRegion = String(currentCountyRegion || '').toUpperCase()
      const hasPlaceholder = activeRegion === US_REGION_CODE || /^US-[A-Z]{2}$/.test(activeRegion)
      headerCountySelect.selectedIndex = hasPlaceholder ? (1 + headerIndex) : headerIndex
    }
  }

  if (headerCountyBtn) {
    const selectedOpt = headerCountySelect?.selectedOptions?.[0]
    const fallbackName = option.countyName || 'County'
    headerCountyBtn.textContent = selectedOpt?.textContent || String(fallbackName)
  }

  if (isCountyRegionCode(region)) {
    activeSortCountyRegion = region
  }

  // Keep state pill in sync when drilling into a county.
  refreshHeaderStateOptions()
  renderStatePickerOptions()

  const resolvedOption = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === region) || option

  resetFiltersForCountySwitch()
  switchToCountyOption(resolvedOption)
}

function refreshSearchRegionOptions() {
  if (!searchRegionSelect) return
  const currentRegion = String(currentCountyRegion || '').toUpperCase()
  const currentIsUs = currentRegion === US_REGION_CODE
  const stateFromCurrent = /^US-[A-Z]{2}$/.test(currentRegion)
    ? currentRegion
    : stateRegionFromCountyRegion(currentRegion)
  const existing = String(searchRegionSelect.value || '').toUpperCase()
  let selectedState = ''
  if (currentIsUs) {
    selectedState = US_REGION_CODE
  } else if (LOWER_48_STATES.some((s) => s.code === stateFromCurrent)) {
    selectedState = stateFromCurrent
  } else if (existing === US_REGION_CODE || LOWER_48_STATES.some((s) => s.code === existing)) {
    selectedState = existing
  }

  searchRegionSelect.innerHTML = [
    '<option value="">Select region…</option>',
    `<option value="${US_REGION_CODE}" ${selectedState === US_REGION_CODE ? 'selected' : ''}>United States</option>`,
    ...LOWER_48_STATES.map((state) => {
      const selected = selectedState && selectedState === state.code
      return `<option value="${escapeHtml(state.code)}" ${selected ? 'selected' : ''}>${escapeHtml(state.name)}</option>`
    }),
  ].join('')
}

function refreshSearchSpeciesOptions(source) {
  if (!searchSpeciesSelect) return
  const speciesSet = new Set()
  ;(Array.isArray(source) ? source : []).forEach((item) => {
    const name = String(item?.comName || '').trim()
    if (name) speciesSet.add(name)
  })
  const species = Array.from(speciesSet).sort((a, b) => a.localeCompare(b))
  const optionsHtml = ['<option value="">All species</option>']
  species.forEach((name) => {
    const isSelected = selectedSpecies === name
    optionsHtml.push(`<option value="${escapeHtml(name)}" ${isSelected ? 'selected' : ''}>${escapeHtml(name)}</option>`)
  })
  searchSpeciesSelect.innerHTML = optionsHtml.join('')
}

function buildStateCountyEntries(source, stateRegion = '') {
  const normalizedState = /^US-[A-Z]{2}$/.test(String(stateRegion || '').toUpperCase())
    ? String(stateRegion || '').toUpperCase()
    : ''
  const buckets = new Map()

  ;(Array.isArray(source) ? source : []).forEach((item) => {
    const itemState = String(item?.subnational1Code || '').toUpperCase()
    if (normalizedState && itemState !== normalizedState) return
    const countyRegion = String(item?.subnational2Code || '').toUpperCase()
    if (!/^US-[A-Z]{2}-\d{3}$/.test(countyRegion)) return
    if (!buckets.has(countyRegion)) {
      buckets.set(countyRegion, [])
    }
    buckets.get(countyRegion).push(item)
  })

  const entries = Array.from(buckets.entries()).map(([countyRegion, items]) => {
    const first = items[0] || {}
    const countyName = String(first?.subnational2Name || countyRegion)
    const latItem = items.find((entry) => Number.isFinite(Number(entry?.lat)) && Number.isFinite(Number(entry?.lng))) || first
    const lat = Number(latItem?.lat)
    const lng = Number(latItem?.lng)
    const summary = summarizeCountyObservations(items)
    return {
      countyRegion,
      countyName,
      count: summary.rarityCount,
      summary,
      lat: Number.isFinite(lat) ? lat : null,
      lng: Number.isFinite(lng) ? lng : null,
    }
  })

  entries.sort((a, b) => a.countyName.localeCompare(b.countyName))
  return entries
}

function applySearchCountyEntries(entries) {
  if (!searchCountySelect) return
  const list = Array.isArray(entries) ? entries : []
  const existing = String(searchCountySelect.value || '').toUpperCase()
  const currentCounty = /^US-[A-Z]{2}-\d{3}$/.test(String(currentCountyRegion || '').toUpperCase())
    ? String(currentCountyRegion || '').toUpperCase()
    : ''
  const selectedCounty = list.some((entry) => entry.countyRegion === existing)
    ? existing
    : (list.some((entry) => entry.countyRegion === currentCounty) ? currentCounty : '')

  searchCountySelect.innerHTML = [
    '<option value="">All counties</option>',
    ...list.map((entry) => {
      const selected = selectedCounty && selectedCounty === entry.countyRegion
      const label = entry.countyRegion
        ? `${entry.countyName} (${String(entry.countyRegion).toUpperCase()})`
        : entry.countyName
      return `<option value="${escapeHtml(entry.countyRegion)}" ${selected ? 'selected' : ''}>${escapeHtml(label)}</option>`
    }),
  ].join('')
  searchCountySelect.disabled = false
}

function setSearchCountyLoading(message = 'Loading counties…') {
  if (!searchCountySelect) return
  searchCountySelect.disabled = true
  searchCountySelect.innerHTML = `<option value="">${escapeHtml(message)}</option>`
}

function setSearchCountyIdleMessage(message = 'Select state first') {
  if (!searchCountySelect) return
  searchCountySelect.disabled = true
  searchCountySelect.innerHTML = `<option value="">${escapeHtml(message)}</option>`
}

function applyCountyPickerOptionsFromStateEntries(entries, activeCountyRegion = '', anchor = null) {
  const list = Array.isArray(entries) ? entries : []
  const activeRegion = String(activeCountyRegion || '').toUpperCase()
  if (!list.length) {
    countyPickerOptions = []
    renderCountyPickerOptions()
    refreshHeaderCountyOptions()
    if (countyDotLayerRef) countyDotLayerRef.clearLayers()
    return
  }

  const anchorLat = Number(anchor?.lat)
  const anchorLng = Number(anchor?.lng)
  const hasAnchorPoint = Number.isFinite(anchorLat) && Number.isFinite(anchorLng)

  const activeEntry = list.find((entry) => entry.countyRegion === activeRegion) || null
  countyPickerOptions = list
    .map((entry) => {
      if (entry?.summary) countySummaryByRegion.set(entry.countyRegion, entry.summary)
      const hasDistanceAnchor = activeEntry && Number.isFinite(activeEntry.lat) && Number.isFinite(activeEntry.lng) && Number.isFinite(entry.lat) && Number.isFinite(entry.lng)
      return {
        countyName: entry.countyName,
        countyRegion: entry.countyRegion,
        lat: entry.lat,
        lng: entry.lng,
        isActive: Boolean(activeRegion && entry.countyRegion === activeRegion),
        distanceKm: hasDistanceAnchor
          ? distanceKm(activeEntry.lat, activeEntry.lng, entry.lat, entry.lng)
          : (hasAnchorPoint && Number.isFinite(entry.lat) && Number.isFinite(entry.lng)
            ? distanceKm(anchorLat, anchorLng, entry.lat, entry.lng)
            : Infinity),
      }
    })
    .sort((a, b) => {
      if (a.isActive && !b.isActive) return -1
      if (!a.isActive && b.isActive) return 1
      if (a.distanceKm !== b.distanceKm) return a.distanceKm - b.distanceKm
      return a.countyName.localeCompare(b.countyName)
    })

  renderCountyPickerOptions()
  refreshHeaderCountyOptions()
}

async function ensureSearchCountyOptionsForState(stateRegion) {
  const requestId = ++latestSearchCountyOptionsRequestId
  const normalizedState = String(stateRegion || '').toUpperCase()
  if (normalizedState === US_REGION_CODE) {
    if (requestId !== latestSearchCountyOptionsRequestId) return
    setSearchCountyIdleMessage('County select disabled for US')
    return
  }
  if (!/^US-[A-Z]{2}$/.test(normalizedState)) {
    if (requestId !== latestSearchCountyOptionsRequestId) return
    setSearchCountyIdleMessage('Select state first')
    return
  }

  const fromCurrent = buildStateCountyEntries(currentRawObservations, normalizedState)
  // If we're currently in a single-county view, currentRawObservations only contains one county,
  // so we still want a full county list for the search menu.
  if (fromCurrent.length > 1) {
    if (requestId !== latestSearchCountyOptionsRequestId) return
    stateCountyOptionsCache.set(normalizedState, fromCurrent)
    applySearchCountyEntries(fromCurrent)
    return
  }

  const cached = stateCountyOptionsCache.get(normalizedState)
  if (Array.isArray(cached) && cached.length > 0) {
    if (requestId !== latestSearchCountyOptionsRequestId) return
    applySearchCountyEntries(cached)
    return
  }

  setSearchCountyLoading('Loading counties…')
  try {
    const observations = await fetchRegionRarities(normalizedState, 14, 30000)
    if (requestId !== latestSearchCountyOptionsRequestId) return
    const entries = buildStateCountyEntries(observations, normalizedState)
    stateCountyOptionsCache.set(normalizedState, entries)
    if (entries.length > 0) {
      applySearchCountyEntries(entries)
    } else {
      setSearchCountyIdleMessage('No counties found')
    }
  } catch {
    if (requestId !== latestSearchCountyOptionsRequestId) return
    setSearchCountyIdleMessage('County load failed')
  }
}

function refreshSearchCountyOptions(source, stateRegion = '') {
  const normalizedState = /^US-[A-Z]{2}$/.test(String(stateRegion || '').toUpperCase())
    ? String(stateRegion || '').toUpperCase()
    : (stateRegionFromCountyRegion(currentCountyRegion || '') || '')
  const entries = buildStateCountyEntries(source, normalizedState)
  if (/^US-[A-Z]{2}$/.test(normalizedState) && entries.length) {
    stateCountyOptionsCache.set(normalizedState, entries)
  }
  applySearchCountyEntries(entries)
}

function activateCountyFromSearchSelection(countyRegion) {
  const targetRegion = String(countyRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}-\d{3}$/.test(targetRegion)) return
  const option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === targetRegion)
  if (option) {
    activateCountyFromOption(option)
    return
  }

  const stateRegion = stateRegionFromCountyRegion(targetRegion)
  const cachedEntries = stateRegion ? stateCountyOptionsCache.get(stateRegion) : null
  if (Array.isArray(cachedEntries) && cachedEntries.length) {
    const cached = cachedEntries.find((entry) => String(entry?.countyRegion || '').toUpperCase() === targetRegion) || null
    if (cached) {
      activateCountyByRegion(
        targetRegion,
        Number.isFinite(cached.lat) ? cached.lat : null,
        Number.isFinite(cached.lng) ? cached.lng : null,
        cached.countyName || ''
      )
      return
    }
  }

  const sample = (Array.isArray(currentRawObservations) ? currentRawObservations : []).find(
    (item) => String(item?.subnational2Code || '').toUpperCase() === targetRegion
      && Number.isFinite(Number(item?.lat))
      && Number.isFinite(Number(item?.lng))
  )
  const countyName = sample?.subnational2Name || sample?.subnational2Code || ''
  const lat = Number(sample?.lat)
  const lng = Number(sample?.lng)
  activateCountyByRegion(
    targetRegion,
    Number.isFinite(lat) ? lat : null,
    Number.isFinite(lng) ? lng : null,
    countyName
  )
}

function updateCountyPickerFromGeojson(geojson) {
  if (!countyPickerList) return
  const features = Array.isArray(geojson?.features) ? geojson.features : []
  const options = features
    .map((feature) => {
      const center = getFeatureCenter(feature)
      if (!center) return null
      const resolvedRegion = String(feature?.properties?.countyRegion || feature?.properties?.subnational2Code || '').toUpperCase() || null
      return {
        countyName: feature?.properties?.countyName || feature?.properties?.NAME || feature?.properties?.name || 'Unknown county',
        countyRegion: resolvedRegion,
        isActive: Boolean(feature?.properties?.isActiveCounty),
        lat: center.lat,
        lng: center.lng,
        summary: getCountySummary(resolvedRegion, Boolean(feature?.properties?.isActiveCounty)),
      }
    })
    .filter(Boolean)

  const active = options.find((opt) => opt.isActive)
  countyPickerOptions = options
    .map((opt) => ({
      ...opt,
      distanceKm: active ? distanceKm(active.lat, active.lng, opt.lat, opt.lng) : Infinity,
    }))
    .sort((a, b) => {
      if (a.isActive && !b.isActive) return -1
      if (!a.isActive && b.isActive) return 1
      if (a.distanceKm !== b.distanceKm) return a.distanceKm - b.distanceKm
      return a.countyName.localeCompare(b.countyName)
    })

  renderCountyPickerOptions()
  refreshHeaderCountyOptions()
  refreshHeaderStateOptions()
  renderStatePickerOptions()
  refreshSearchRegionOptions()
  prefetchCountySummariesForPicker(countyPickerOptions)
}

function setTableRenderStatus(message) {
  if (!tableRenderStatus) return
  tableRenderStatus.textContent = `render: ${message}`
}

function updateStatPills(total, confirmed, pending) {
  // Confirmed/pending pills removed; keep function as a harmless no-op.
}

function renderAbaStatPills(sorted) {
  if (!topAbaPills && !pickerAbaPills && !statePickerAbaPills) return
  const counts = new Map()
  sorted.forEach((item) => {
    const code = Number.isFinite(item.abaCode) ? item.abaCode : null
    if (code !== null) counts.set(code, (counts.get(code) || 0) + 1)
  })

  const orderedCodes = [1, 2, 3, 4, 5, 6]
  const html = orderedCodes
    .map((c) => {
      const count = counts.get(c) || 0
      const isActive = selectedAbaCodes instanceof Set && selectedAbaCodes.has(c)
      return `<button type="button" class="stat-aba-pill${isActive ? ' is-active' : ''}" data-code="${c}" aria-pressed="${isActive ? 'true' : 'false'}" title="Toggle ABA ${c} filter"><span class="stat-aba-pill-badge aba-code-${c}"><span class="aba-pill-count">${count}</span></span><span class="stat-aba-pill-code" aria-hidden="true">${c}</span></button>`
    })
    .join('')

  if (topAbaPills) topAbaPills.innerHTML = html
  if (pickerAbaPills) pickerAbaPills.innerHTML = html
  if (statePickerAbaPills) statePickerAbaPills.innerHTML = html
}

function setNotablesUnavailableState(metaMessage, rowMessage, statusMessage = 'notables-unavailable') {
  notableCount.className = 'badge warn'
  notableCount.textContent = '0'
  notableMeta.textContent = metaMessage
  updateStatPills('—', '—', '—')
  notableRows.innerHTML = `<tr><td colspan="7">${rowMessage}</td></tr>`
  setTableRenderStatus(statusMessage)
}

function supportsPermissionsApi() {
  return typeof navigator !== 'undefined' && 'permissions' in navigator && typeof navigator.permissions.query === 'function'
}

async function getGeolocationPermissionState() {
  if (!supportsPermissionsApi()) {
    return 'unknown'
  }

  try {
    const result = await navigator.permissions.query({ name: 'geolocation' })
    return result.state
  } catch {
    return 'unknown'
  }
}

function getCurrentPositionAsync(options) {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject, options)
  })
}

function initializeMap() {
  if (map) {
    return
  }

  map = L.map('map', {
    preferCanvas: true,
    zoomControl: false,
    attributionControl: true,
    zoomSnap: 1,
    zoomDelta: 1,
    zoomAnimation: false,
    fadeAnimation: false,
    markerZoomAnimation: false,
    wheelDebounceTime: 45,
    wheelPxPerZoomLevel: 190,
  }).setView([39.5, -98.35], 5)
  mapPointRenderer = L.canvas({ padding: 0.5 })

  map.createPane('countyMaskPane')
  map.getPane('countyMaskPane').style.zIndex = '380'
  map.getPane('countyMaskPane').style.pointerEvents = 'none'
  map.createPane('countyNeighborPane')
  // Keep outlines above the mask (and above label tiles) for visibility.
  map.getPane('countyNeighborPane').style.zIndex = '417'
  map.getPane('countyNeighborPane').style.pointerEvents = 'auto'
  map.createPane('countyDotPane')
  map.getPane('countyDotPane').style.zIndex = '405'
  map.getPane('countyDotPane').style.pointerEvents = 'auto'
  map.createPane('activeCountyPane')
  map.getPane('activeCountyPane').style.zIndex = '418'
  map.createPane('countyNamePane')
  map.getPane('countyNamePane').style.zIndex = '416'
  map.getPane('countyNamePane').style.pointerEvents = 'none'
  map.createPane('labelsPane')
  map.getPane('labelsPane').style.zIndex = '415'
  map.getPane('labelsPane').style.pointerEvents = 'none'
  map.createPane('notablePane')
  map.getPane('notablePane').style.zIndex = '420'
  map.getPane('notablePane').style.pointerEvents = 'auto'
  map.createPane('userDotPane')
  map.getPane('userDotPane').style.zIndex = '430'

  osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    ...BASE_TILE_OPTIONS,
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  })

  placeNameLayer = L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
    {
      ...BASE_TILE_OPTIONS,
      maxZoom: 19,
      subdomains: 'abcd',
      pane: 'labelsPane',
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
    }
  )

  satelliteLayer = L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    {
      ...BASE_TILE_OPTIONS,
      maxZoom: 19,
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, USDA FSA'
    }
  )

  satelliteLayer.addTo(map)
  placeNameLayer.addTo(map)
  // Warm street tiles once to reduce perceived loading on first toggle
  osmLayer.addTo(map)
  map.removeLayer(osmLayer)
  if (mapBasemapToggleBtn) {
    mapBasemapToggleBtn.title = 'Switch to Street map'
  }
  updateBasemapAuxLayers()

  // High-res county outline when zoomed in close; revert to lo-res when zoomed back out
  map.on('zoomend', () => {
    const z = map.getZoom()
    if (!currentCountyRegion) return
    updateCountyDots()
    if (z > 9 && isCountyRegionCode(currentCountyRegion)) {
      applyHiResCountyOutline(currentCountyRegion)
    } else if (latestCountyContextGeojson) {
      const overlayRegion = String(latestCountyContextGeojson?.activeCountyRegion || '').toUpperCase()
      const isStateOverlayMode = /^US-[A-Z]{2}$/.test(overlayRegion)
      const activeFeatures = Array.isArray(latestCountyContextGeojson?.features)
        ? latestCountyContextGeojson.features.filter((f) => f?.properties?.isActiveCounty)
        : []

      if (countyOverlay) {
        countyOverlay.clearLayers()
        if (isStateOverlayMode && Array.isArray(latestCountyContextGeojson?.inverseMaskFeatures)) {
          countyOverlay.addData({ type: 'FeatureCollection', features: latestCountyContextGeojson.inverseMaskFeatures })
        } else {
          const maskFeatures = buildInverseMaskFeaturesFromActiveFeatures(activeFeatures)
          countyOverlay.addData({ type: 'FeatureCollection', features: maskFeatures.length ? maskFeatures : activeFeatures })
        }
      }

      if (activeOutlineLayerRef) {
        activeOutlineLayerRef.clearLayers()
        if (!isStateOverlayMode && activeFeatures.length) {
          activeOutlineLayerRef.addData({ type: 'FeatureCollection', features: activeFeatures })
        }
        updateCountyLineColors()
      }
    }
  })
}

function updateBasemapAuxLayers() {
  if (!map) return
  const mapEl = document.querySelector('#map')
  if (mapEl) {
    mapEl.classList.toggle('is-satellite', currentBasemap === 'satellite')
    mapEl.classList.toggle('is-osm', currentBasemap === 'osm')
  }
  if (!placeNameLayer) return
  if (currentBasemap === 'satellite') {
    if (!map.hasLayer(placeNameLayer)) placeNameLayer.addTo(map)
  } else if (map.hasLayer(placeNameLayer)) {
    map.removeLayer(placeNameLayer)
  }
}

function updateCountyLineColors() {
  const isSat = currentBasemap === 'satellite'
  const neighborStroke = isSat ? '#94a3b8' : '#64748b'
  const neighborFill  = isSat ? '#94a3b8' : '#94a3b8'
  const activeStroke  = isSat ? '#ffffff' : '#dc2626'
  const activeMaskFill = isSat ? '#94a3b8' : '#cbd5e1'
  const isCounty = isCountyRegionCode(currentCountyRegion)
  const z = map ? map.getZoom() : 0
  const hideNeighborVisuals = isCounty && z > 9
  if (neighborLayerRef) {
    neighborLayerRef.setStyle({
      // When zoomed in tightly on the active county, suppress neighbor fills for clarity,
      // but keep boundary strokes so county lines remain visible under the mask.
      color: neighborStroke,
      weight: 0.75,
      fillColor: neighborFill,
      fillOpacity: hideNeighborVisuals ? 0 : (isCounty ? 0.46 : 0),
    })
  }
  if (countyOverlay) {
    countyOverlay.setStyle({ color: 'transparent', weight: 0, fillColor: activeMaskFill, fillOpacity: 0.28, fillRule: 'evenodd' })
  }
  if (activeOutlineLayerRef) {
    activeOutlineLayerRef.setStyle({ color: activeStroke, weight: 1, fillOpacity: 0 })
  }
}

function setMode(mode) {
  const showingMap = mode === 'map'
  panelMap.classList.toggle('active', showingMap)
  panelTable.classList.toggle('active', !showingMap)

  if (showingMap) {
    initializeMap()
    window.setTimeout(() => map.invalidateSize(), 150)
  }
}

async function triggerHardRefresh() {
  setMapLoading(true, 'Refreshing…')

  try {
    localStorage.removeItem('mrm_last_pos')
    localStorage.removeItem('mrm_runtime_log')
    const keysToRemove = []
    for (let index = 0; index < localStorage.length; index += 1) {
      const key = localStorage.key(index)
      if (!key) continue
      if (key.startsWith('notables:') || key.startsWith('county_context:')) {
        keysToRemove.push(key)
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key))
  } catch {
    // ignore storage cleanup errors
  }

  if ('serviceWorker' in navigator) {
    const registrations = await navigator.serviceWorker.getRegistrations()
    await Promise.all(registrations.map((registration) => registration.unregister()))
  }

  if ('caches' in window) {
    const keys = await caches.keys()
    await Promise.all(keys.map((key) => caches.delete(key)))
  }

  const url = new URL(window.location.href)
  url.searchParams.set('refresh', String(Date.now()))
  url.searchParams.set('force_location', '1')
  window.location.replace(url.toString())
}

function setMapFullscreen(open) {
  isMapFullscreen = open
  appShell.classList.toggle('map-fullscreen', open)
  mapFullscreenToggleBtn.setAttribute('aria-pressed', String(open))
  // Swap to compress icon when fullscreen
  const svg = mapFullscreenToggleBtn.querySelector('svg')
  if (svg) {
    svg.setAttribute('fill', 'none')
    svg.setAttribute('stroke', 'currentColor')
    svg.setAttribute('stroke-width', '2')
    svg.setAttribute('stroke-linecap', 'round')
    svg.setAttribute('stroke-linejoin', 'round')
    svg.innerHTML = open
      ? '<polyline points="20 9 20 4 15 4"/><polyline points="4 15 4 20 9 20"/><line x1="20" y1="4" x2="13" y2="11"/><line x1="4" y1="20" x2="11" y2="13"/>'
      : '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>'  
  }
  window.setTimeout(() => {
    if (map) map.invalidateSize()
  }, 180)
}

function setStatusPopoverOpen(open) {
  if (!statusPopover) return
  statusPopover.classList.toggle('open', open)
  statusPopover.setAttribute('aria-hidden', String(!open))
}

async function checkApi() {
  apiStatus.className = 'badge warn'
  apiStatus.textContent = 'Checking...'
  apiDetail.textContent = `Endpoint: ${API_BASE_URL} · Build ${BUILD_TAG}`
  if (buildInfo) {
    buildInfo.textContent = `Build: ${BUILD_TAG}`
  }
  try {
    const data = await fetchWorkerHealth(getStoredEbirdApiKey())
    apiStatus.className = 'badge ok'
    apiStatus.textContent = 'Connected'
    apiDetail.textContent = `Endpoint: ${API_BASE_URL} · Regions loaded: ${Array.isArray(data) ? data.length : 0} · Build ${BUILD_TAG}`
  } catch (error) {
    apiStatus.className = 'badge warn'
    apiStatus.textContent = 'Unavailable'
    apiDetail.textContent = `Endpoint: ${API_BASE_URL} · ${error.message} · Build ${BUILD_TAG}`
    console.error(error)
  } finally {
    updateRuntimeLog()
  }
}

function normalizeEbirdApiKey(value) {
  return String(value || '').trim()
}

function getStoredEbirdApiKey() {
  try {
    const raw = sessionStorage.getItem(EBIRD_API_KEY_STORAGE_KEY)
    const key = normalizeEbirdApiKey(raw)
    return key || null
  } catch {
    return null
  }
}

function setStoredEbirdApiKey(value) {
  const key = normalizeEbirdApiKey(value)
  if (!key) return false
  try {
    sessionStorage.setItem(EBIRD_API_KEY_STORAGE_KEY, key)
    return true
  } catch {
    return false
  }
}

function maybeSeedEbirdApiKeyFromUrl() {
  const url = new URL(window.location.href)
  const candidates = ['ebird_api_key', 'ebirdKey', 'api_key']
  let seeded = false
  for (const name of candidates) {
    const v = url.searchParams.get(name)
    if (!v) continue
    if (setStoredEbirdApiKey(v)) seeded = true
    url.searchParams.delete(name)
  }
  if (seeded) {
    window.history.replaceState({}, '', url.toString())
  }
  return seeded
}

function showApiKeyGate(message = '') {
  if (!apiKeyGate) return
  if (apiKeyError) apiKeyError.textContent = message
  setApiKeyInputVisibility(false)
  apiKeyGate.removeAttribute('hidden')
  window.setTimeout(() => {
    try { apiKeyInput?.focus() } catch { /* ignore */ }
  }, 50)
}

function hideApiKeyGate() {
  if (!apiKeyGate) return
  apiKeyGate.setAttribute('hidden', 'hidden')
  if (apiKeyError) apiKeyError.textContent = ''
}

async function testEbirdApiKey(candidateKey) {
  const key = normalizeEbirdApiKey(candidateKey)
  if (!key) return { ok: false, message: 'Paste your eBird API key to continue.' }
  const endpoint = `${API_BASE_URL}/api/aba_meta`
  const controller = new AbortController()
  const timer = window.setTimeout(() => controller.abort(), 9000)
  try {
    const res = await fetch(endpoint, {
      cache: 'no-store',
      signal: controller.signal,
      headers: { 'X-eBirdApiToken': key },
    })
    if (res.status === 401) {
      return { ok: false, message: 'Invalid API key (401). Re-check and try again.' }
    }
    if (!res.ok) {
      const txt = await res.text().catch(() => '')
      return { ok: false, message: `Key test failed (${res.status}). ${txt ? txt.slice(0, 80) : ''}`.trim() }
    }
    const data = await res.json().catch(() => null)
    const maxCode = Number(data?.maxCode)
    if (!Number.isFinite(maxCode) || maxCode < 1) {
      return { ok: false, message: 'Key test returned unexpected response. Try again.' }
    }
    return { ok: true, message: '' }
  } catch (e) {
    const isTimeout = e?.name === 'AbortError'
    return { ok: false, message: isTimeout ? 'Key test timed out. Try again.' : `Key test error: ${String(e?.message || e)}` }
  } finally {
    window.clearTimeout(timer)
  }
}

const EYE_ICON_SVG = `
  <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7-10-7-10-7z"></path>
    <circle cx="12" cy="12" r="3"></circle>
  </svg>
`

const EYE_OFF_ICON_SVG = `
  <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M2 12s3.5-7 10-7c1.2 0 2.3.2 3.2.6"></path>
    <path d="M22 12s-3.5 7-10 7c-1.2 0-2.3-.2-3.2-.6"></path>
    <path d="M9.9 9.9a3 3 0 0 0 4.2 4.2"></path>
    <path d="M3 3l18 18"></path>
  </svg>
`

function setApiKeyInputVisibility(visible) {
  const show = Boolean(visible)
  if (apiKeyInput) apiKeyInput.type = show ? 'text' : 'password'
  if (apiKeyToggleBtn) {
    apiKeyToggleBtn.setAttribute('aria-pressed', show ? 'true' : 'false')
    apiKeyToggleBtn.setAttribute('aria-label', show ? 'Hide API key' : 'Show API key')
    apiKeyToggleBtn.title = show ? 'Hide API key' : 'Show API key'
    apiKeyToggleBtn.innerHTML = show ? EYE_OFF_ICON_SVG : EYE_ICON_SVG
  }
}

function shouldSendEbirdTokenHeader(urlString) {
  try {
    const base = new URL(API_BASE_URL, window.location.href)
    const resolved = new URL(urlString, window.location.href)
    if (resolved.origin !== base.origin) return false
    const basePath = String(base.pathname || '').replace(/\/$/, '')
    return resolved.pathname.startsWith(`${basePath}/api/`)
  } catch {
    return false
  }
}

function buildWorkerAuthHeaders(urlString) {
  const key = getStoredEbirdApiKey()
  if (!key) return {}
  if (!shouldSendEbirdTokenHeader(urlString)) return {}
  return { 'X-eBirdApiToken': key }
}

async function fetchWithTimeout(url, timeoutMs = API_TIMEOUT_MS) {
  const controller = new AbortController()
  const timer = window.setTimeout(() => controller.abort(), timeoutMs)
  try {
    const headers = buildWorkerAuthHeaders(url)
    const response = await fetch(url, { cache: 'no-store', signal: controller.signal, headers })
    if (response.status === 401) {
      showApiKeyGate('API key required. Get a key from https://ebird.org/api/keygen and paste it here.')
    }
    return response
  } catch (error) {
    if (error?.name === 'AbortError') {
      throw new Error(`Request timed out after ${Math.round(timeoutMs / 1000)}s`)
    }
    throw error
  } finally {
    window.clearTimeout(timer)
  }
}

async function fetchCountyOutline(latitude, longitude) {
  const endpoint = `${API_BASE_URL}/api/county_outline?lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}`
  const response = await fetchWithTimeout(endpoint, 20000)

  if (!response.ok) {
    throw new Error(`County outline request failed: ${response.status}`)
  }

  return response.json()
}

async function fetchCountyHiRes(countyRegion) {
  if (hiResCache.has(countyRegion)) return hiResCache.get(countyRegion)
  const endpoint = `${API_BASE_URL}/api/county_hires?countyRegion=${encodeURIComponent(countyRegion)}`
  const response = await fetchWithTimeout(endpoint, 15000)
  if (!response.ok) throw new Error(`County hi-res request failed: ${response.status}`)
  const data = await response.json()
  hiResCache.set(countyRegion, data)
  return data
}

// Apply hi-res outline if already zoomed in after county load
function maybeApplyHiResOnCountyLoad() {
  if (map && isCountyRegionCode(currentCountyRegion) && map.getZoom() > 9) {
    void applyHiResCountyOutline(currentCountyRegion)
  }
}

async function applyHiResCountyOutline(countyRegion) {
  if (!countyRegion || !activeOutlineLayerRef) return
  if (hiResSwapInProgress) return
  hiResSwapInProgress = true
  try {
    const hiGeo = await fetchCountyHiRes(countyRegion)
    if (!hiGeo?.features?.length) return
    // Only apply if the county is still the active one
    if (currentCountyRegion !== countyRegion) return
    if (countyOverlay) {
      countyOverlay.clearLayers()
      const maskFeatures = buildInverseMaskFeaturesFromActiveFeatures(hiGeo.features)
      countyOverlay.addData({ type: 'FeatureCollection', features: maskFeatures.length ? maskFeatures : hiGeo.features })
    }
    activeOutlineLayerRef.clearLayers()
    activeOutlineLayerRef.addData({ type: 'FeatureCollection', features: hiGeo.features })
    updateCountyLineColors()
  } catch (e) {
    console.warn('[hi-res] County hi-res fetch failed:', e)
  } finally {
    hiResSwapInProgress = false
  }
}

async function fetchCountyNotables(latitude, longitude, back = 3, countyRegion = null) {
  const params = new URLSearchParams({
    lat: String(latitude),
    lon: String(longitude),
    back: String(back),
  })
  if (countyRegion) {
    params.set('countyRegion', countyRegion)
  }
  const endpoint = `${API_BASE_URL}/api/county_notables?${params.toString()}`
  const response = await fetchWithTimeout(endpoint, COUNTY_NOTABLES_TIMEOUT_MS)
  if (!response.ok) {
    throw new Error(`County notable request failed: ${response.status}`)
  }
  return response.json()
}

async function fetchCountyNotablesWithRetry(latitude, longitude, back = 14, countyRegion = null, attempts = 1) {
  let lastError = null

  for (let index = 0; index < attempts; index += 1) {
    try {
      return await fetchCountyNotables(latitude, longitude, back, countyRegion)
    } catch (error) {
      lastError = error
      const isLastAttempt = index === attempts - 1
      if (isLastAttempt) break
      await new Promise((resolve) => setTimeout(resolve, 300 * (index + 1)))
    }
  }

  throw lastError || new Error('County notable request failed')
}

function buildNotablesCacheKey(countyRegion) {
  return countyRegion ? `notables:${countyRegion}` : null
}

function saveNotablesCache(countyRegion, result) {
  const cacheKey = buildNotablesCacheKey(countyRegion)
  if (!cacheKey) return
  if (!Array.isArray(result?.observations) || result.observations.length === 0) return

  try {
    localStorage.setItem(cacheKey, JSON.stringify({
      timestamp: Date.now(),
      result,
    }))
  } catch {
    // ignore storage errors
  }
}

function loadNotablesCache(countyRegion, maxAgeMs = 6 * 60 * 60 * 1000) {
  const cacheKey = buildNotablesCacheKey(countyRegion)
  if (!cacheKey) return null

  try {
    const raw = localStorage.getItem(cacheKey)
    if (!raw) return null
    const parsed = JSON.parse(raw)
    if (!parsed || typeof parsed !== 'object') return null
    const age = Date.now() - Number(parsed.timestamp || 0)
    if (!Number.isFinite(age) || age < 0 || age > maxAgeMs) return null
    return parsed.result || null
  } catch {
    return null
  }
}

function countyContextCacheKey(lat, lng) {
  return `county_context:${Number(lat).toFixed(2)},${Number(lng).toFixed(2)}`
}

function saveCountyContextCache(lat, lng, geojson) {
  try {
    localStorage.setItem(countyContextCacheKey(lat, lng), JSON.stringify({ timestamp: Date.now(), geojson }))
  } catch {
    // ignore storage errors
  }
}

function loadCountyContextCache(lat, lng, maxAgeMs = 24 * 60 * 60 * 1000) {
  try {
    const raw = localStorage.getItem(countyContextCacheKey(lat, lng))
    if (!raw) return null
    const parsed = JSON.parse(raw)
    if (!parsed?.geojson) return null
    const age = Date.now() - Number(parsed.timestamp || 0)
    if (!Number.isFinite(age) || age < 0 || age > maxAgeMs) return null
    return parsed.geojson
  } catch {
    return null
  }
}

async function fetchCountyContextWithCache(lat, lng) {
  const cached = loadCountyContextCache(lat, lng)
  if (cached) return cached
  const geojson = await fetchCountyOutline(lat, lng)
  saveCountyContextCache(lat, lng, geojson)
  return geojson
}

async function fetchStateCountyGeometry(stateRegion) {
  const normalizedState = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(normalizedState)) return null
  const stateCode = normalizedState.split('-')[1]
  const endpoint = `./data/counties/${stateCode}.json`
  const response = await fetchWithTimeout(endpoint, 12000)
  if (!response.ok) {
    throw new Error(`State county geometry request failed: ${response.status}`)
  }
  return response.json()
}

async function fetchRegionRarities(region, back = 7, timeoutMs = API_TIMEOUT_MS, options = {}) {
  const params = new URLSearchParams({
    region: String(region || ''),
    back: String(back),
  })
  const abaMin = Number(options?.abaMin)
  if (Number.isFinite(abaMin) && abaMin >= 1) {
    params.set('abaMin', String(Math.round(abaMin)))
  }
  const endpoint = `${API_BASE_URL}/api/rarities?${params.toString()}`
  let response
  try {
    response = await fetchWithTimeout(endpoint, timeoutMs)
  } catch (error) {
    const details = error instanceof Error ? error.message : String(error)
    throw new Error(`Network error fetching ${endpoint}: ${details}`)
  }
  if (!response.ok) {
    const body = await response.text().catch(() => '')
    throw new Error(`Region rarities ${response.status}: ${body.slice(0, 120)}`)
  }
  const data = await response.json()
  // API may return plain array or { observations: [] }
  return Array.isArray(data) ? data : (Array.isArray(data?.observations) ? data.observations : [])
}

function stateRegionFromCountyRegion(countyRegion) {
  if (!countyRegion || !/^US-[A-Z]{2}-\d{3}$/.test(countyRegion)) return null
  return countyRegion.slice(0, 5)
}

function isCountyRegionCode(region) {
  return /^US-[A-Z]{2}-\d{3}$/.test(String(region || '').toUpperCase())
}

function getStateNameByRegion(stateRegion) {
  const normalizedState = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(normalizedState)) return normalizedState
  const found = LOWER_48_STATES.find((state) => state.code === normalizedState)
  return found?.name || normalizedState
}

function normalizeRingCoordinates(ring) {
  if (!Array.isArray(ring) || ring.length < 3) return null
  const points = ring
    .map((point) => {
      if (!Array.isArray(point) || point.length < 2) return null
      const lng = Number(point[0])
      const lat = Number(point[1])
      if (!Number.isFinite(lng) || !Number.isFinite(lat)) return null
      return [lng, lat]
    })
    .filter(Boolean)

  if (points.length < 3) return null

  const first = points[0]
  const last = points[points.length - 1]
  if (first[0] !== last[0] || first[1] !== last[1]) {
    points.push([first[0], first[1]])
  }

  return points
}

function buildInverseMaskFeaturesFromActiveFeatures(activeFeatures) {
  const holes = []

  ;(Array.isArray(activeFeatures) ? activeFeatures : []).forEach((feature) => {
    const geometry = feature?.geometry
    if (!geometry) return

    if (geometry.type === 'Polygon' && Array.isArray(geometry.coordinates)) {
      const outerRing = normalizeRingCoordinates(geometry.coordinates[0])
      if (outerRing) holes.push(outerRing)
      return
    }

    if (geometry.type === 'MultiPolygon' && Array.isArray(geometry.coordinates)) {
      geometry.coordinates.forEach((polygonCoordinates) => {
        if (!Array.isArray(polygonCoordinates)) return
        const outerRing = normalizeRingCoordinates(polygonCoordinates[0])
        if (outerRing) holes.push(outerRing)
      })
    }
  })

  if (!holes.length) return []

  const worldRing = [
    [-180, -90],
    [-180, 90],
    [180, 90],
    [180, -90],
    [-180, -90],
  ]

  return [{
    type: 'Feature',
    properties: {
      isInverseMask: true,
    },
    geometry: {
      type: 'Polygon',
      coordinates: [worldRing, ...holes],
    },
  }]
}

function buildStateMaskGeojson(stateRegion, sourceGeojson) {
  if (!sourceGeojson || !Array.isArray(sourceGeojson.features)) return null
  const normalizedState = String(stateRegion || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(normalizedState)) return null

  const features = sourceGeojson.features.map((feature) => {
    const regionRaw = feature?.properties?.countyRegion || feature?.properties?.subnational2Code || null
    const region = regionRaw ? String(regionRaw).toUpperCase() : null
    return {
      ...feature,
      properties: {
        ...(feature?.properties || {}),
        countyRegion: region,
        isActiveCounty: false,
      },
    }
  })

  const inverseMaskFeatures = buildInverseMaskFeaturesFromActiveFeatures(features)

  return {
    ...sourceGeojson,
    activeCountyRegion: normalizedState,
    activeLabel: getStateNameByRegion(normalizedState),
    inverseMaskFeatures,
    features,
  }
}

function setLocationUiChecking() {
  locationStatus.className = 'badge warn'
  locationStatus.textContent = 'Checking...'
  locationDetail.textContent = 'Requesting device location permission.'
}

function setLocationUiUnavailable(message) {
  locationStatus.className = 'badge warn'
  locationStatus.textContent = 'Unavailable'
  locationDetail.textContent = message
}

function setLocationUiBlocked() {
  locationStatus.className = 'badge warn'
  locationStatus.textContent = 'Blocked'
  locationDetail.textContent = 'Location permission is blocked. On iOS: Settings → Privacy & Security → Location Services → Safari Websites (or your Home Screen app) → While Using + Precise ON.'
}

function updateUserLocationOnMap(latitude, longitude, accuracyMeters) {
  initializeMap()
  const hasAccuracy = Number.isFinite(accuracyMeters) && accuracyMeters > 0
  const safeAccuracy = hasAccuracy ? accuracyMeters : null

  if (!userDot) {
    userDot = L.circleMarker([latitude, longitude], {
      radius: 8,
      color: '#ffffff',
      weight: 1.4,
      fillColor: '#7c3aed',
      fillOpacity: 1,
      pane: 'userDotPane',
    }).addTo(map)
  } else {
    userDot.setLatLng([latitude, longitude])
  }

  if (!hasAccuracy) {
    if (accuracyCircle) {
      accuracyCircle.remove()
      accuracyCircle = null
    }
  } else if (!accuracyCircle) {
    accuracyCircle = L.circle([latitude, longitude], {
      radius: safeAccuracy,
      color: '#009688',
      fillColor: '#009688',
      fillOpacity: 0.2,
      weight: 1.5
    }).addTo(map)
  } else {
    accuracyCircle.setLatLng([latitude, longitude])
    accuracyCircle.setRadius(safeAccuracy)
  }

  // Don't zoom here — fitBounds in renderNotablesOnMap controls the viewport
  markMapPartReady('location')
}

function drawCountyOverlay(geojson) {
  initializeMap()
  latestCountyContextGeojson = geojson
  updateCountyPickerFromGeojson(geojson)

  const allFeatures = Array.isArray(geojson?.features) ? geojson.features : []
  const activeOverlayRegion = String(geojson?.activeCountyRegion || '').toUpperCase()
  const isStateOverlayMode = /^US-[A-Z]{2}$/.test(activeOverlayRegion)
  const neighborFeatures = isStateOverlayMode
    ? allFeatures
    : allFeatures.filter((f) => !f?.properties?.isActiveCounty)
  const activeFeatures = isStateOverlayMode
    ? []
    : allFeatures.filter((f) => f?.properties?.isActiveCounty)
  const overlayFeatures = (isStateOverlayMode && Array.isArray(geojson?.inverseMaskFeatures))
    ? geojson.inverseMaskFeatures
    : (() => {
      const maskFeatures = buildInverseMaskFeaturesFromActiveFeatures(activeFeatures)
      return maskFeatures.length ? maskFeatures : activeFeatures
    })()

  const isSat = currentBasemap === 'satellite'
  const neighborStroke = isSat ? '#94a3b8' : '#64748b'
  const activeStroke = isSat ? '#ffffff' : '#dc2626'
  const hideNeighborVisuals = isCountyRegionCode(currentCountyRegion) && map && map.getZoom() > 9

  const flashNeighborLayer = (layer) => {
    if (!layer || typeof layer.setStyle !== 'function') return
    const nowSat = currentBasemap === 'satellite'
    const isCounty = isCountyRegionCode(currentCountyRegion)
    const baseStyle = hideNeighborVisuals
      ? { fillOpacity: 0, fillColor: '#94a3b8', color: nowSat ? '#94a3b8' : '#64748b', weight: 0.75 }
      : { fillOpacity: isCounty ? 0.46 : 0, fillColor: '#94a3b8', color: nowSat ? '#94a3b8' : '#64748b', weight: 0.75 }
    layer.setStyle({ fillOpacity: 0.72, fillColor: '#fde047', color: '#f59e0b', weight: 1.25 })
    if (layer._flashTimer) window.clearTimeout(layer._flashTimer)
    layer._flashTimer = window.setTimeout(() => {
      try {
        layer.setStyle(baseStyle)
      } catch {
        // ignore layer reset errors during rapid county switches
      }
      layer._flashTimer = null
    }, 220)
  }

  if (!neighborLayerRef) {
    neighborLayerRef = L.geoJSON(null, {
      pane: 'countyNeighborPane',
      style: hideNeighborVisuals
        ? { color: neighborStroke, weight: 0.75, fillColor: '#94a3b8', fillOpacity: 0 }
        : { color: neighborStroke, weight: 0.75, fillColor: '#94a3b8', fillOpacity: 0.46 },
      onEachFeature: (feature, layer) => {
        const region = String(feature?.properties?.countyRegion || feature?.properties?.subnational2Code || '').toUpperCase() || null
        const name = feature?.properties?.countyName || feature?.properties?.NAME || feature?.properties?.name || ''
        layer.on({
          click: (e) => {
            if (e?.originalEvent) {
              L.DomEvent.stopPropagation(e.originalEvent)
              L.DomEvent.preventDefault(e.originalEvent)
            }
            flashNeighborLayer(layer)
            const tapLat = Number(e?.latlng?.lat)
            const tapLng = Number(e?.latlng?.lng)
            switchCountyFromMapTap(
              region,
              Number.isFinite(tapLat) ? tapLat : null,
              Number.isFinite(tapLng) ? tapLng : null,
              name,
              'neighbor-polygon'
            )
          },
          mouseover: () => {
            if (hideNeighborVisuals) return
            const isCounty = isCountyRegionCode(currentCountyRegion)
            layer.setStyle({ fillOpacity: isCounty ? 0.56 : 0.2, fillColor: '#94a3b8', color: '#475569', weight: 1 })
          },
          mouseout: () => {
            if (hideNeighborVisuals) return
            const nowSat = currentBasemap === 'satellite'
            const isCounty = isCountyRegionCode(currentCountyRegion)
            layer.setStyle({ fillOpacity: isCounty ? 0.46 : 0, fillColor: '#94a3b8', color: nowSat ? '#94a3b8' : '#64748b', weight: 0.75 })
          },
        })
      },
    }).addTo(map)
  }

  if (!activeOutlineLayerRef) {
    activeOutlineLayerRef = L.geoJSON(null, {
      pane: 'activeCountyPane',
      style: { color: activeStroke, weight: 1, fillOpacity: 0, fillColor: 'transparent' },
    }).addTo(map)
  }

  if (!countyOverlay) {
    countyOverlay = L.geoJSON(null, {
      pane: 'countyMaskPane',
      style: { color: 'transparent', weight: 0, fillColor: '#94a3b8', fillOpacity: 0.28, fillRule: 'evenodd' },
      interactive: false,
    }).addTo(map)
  }

  if (!countyNameLayerRef) {
    countyNameLayerRef = L.layerGroup().addTo(map)
  }

  neighborLayerRef.clearLayers()
  countyOverlay.clearLayers()
  activeOutlineLayerRef.clearLayers()
  countyNameLayerRef.clearLayers()
  neighborLayerRef.addData({ type: 'FeatureCollection', features: neighborFeatures })
  countyOverlay.addData({ type: 'FeatureCollection', features: overlayFeatures })
  activeOutlineLayerRef.addData({ type: 'FeatureCollection', features: activeFeatures })

  updateCountyLineColors()

  updateCountyDots()

  // Set county label pill immediately when GeoJSON resolves — don't wait for caller chain
  const activeFeature = activeFeatures[0] || null
  const activeCountyRegion = String(activeFeature?.properties?.countyRegion || geojson?.activeCountyRegion || '').toUpperCase() || null
  const activeCountyName = geojson?.activeLabel
    || activeFeature?.properties?.countyName
    || activeFeature?.properties?.NAME
    || activeFeature?.properties?.name
    || null

  if (map && isCountyRegionCode(activeCountyRegion) && map.getZoom() > 9) {
    void applyHiResCountyOutline(activeCountyRegion)
  }

  markMapPartReady('activeCounty')
  markMapPartReady('stateMask')
}

function formatObservationDate(rawValue) {
  if (!rawValue) return '—'
  const parsed = new Date(rawValue)
  if (Number.isNaN(parsed.getTime())) return String(rawValue)
  return parsed.toLocaleString(undefined, {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  })
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
}

function parseFirstAvailableObsDate(...values) {
  for (const value of values) {
    const parsed = parseObsDate(value)
    if (parsed) return parsed
  }
  return null
}

function getObservationGroupKey(item) {
  const species = item?.comName || ''
  const state = getItemStateAbbrev(item)
  const county = getItemCountyName(item)
  return `${species}::${state}::${county}`
}

function getDistanceAnchorPoint() {
  if (Number.isFinite(lastCountyAnchorLat) && Number.isFinite(lastCountyAnchorLng)) {
    return { lat: lastCountyAnchorLat, lng: lastCountyAnchorLng }
  }
  if (Number.isFinite(lastUserLat) && Number.isFinite(lastUserLng)) {
    return { lat: lastUserLat, lng: lastUserLng }
  }
  if (map) {
    const center = map.getCenter()
    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {
      return { lat: center.lat, lng: center.lng }
    }
  }
  return null
}

function computeClosestPointByGroup(observations, anchorLat, anchorLng) {
  const closest = new Map()
  const source = Array.isArray(observations) ? observations : []
  source.forEach((item) => {
    const lat = Number(item?.lat)
    const lng = Number(item?.lng)
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) return
    const key = getObservationGroupKey(item)
    const d = distanceKm(anchorLat, anchorLng, lat, lng)
    const prev = closest.get(key)
    if (!prev || d < prev.distanceKm) {
      closest.set(key, { distanceKm: d, lat, lng })
    }
  })
  return closest
}

function parseObsDate(obsDt) {
  if (!obsDt) return null
  if (obsDt instanceof Date) {
    return Number.isNaN(obsDt.getTime()) ? null : obsDt
  }
  const raw = String(obsDt).trim()
  if (!raw) return null

  // eBird payloads often use date-only strings like "YYYY-MM-DD".
  // JS parses those as UTC midnight, which can shift the local day and
  // break day-based filtering/aggregation. Parse them as local dates.
  const mDateOnly = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/)
  if (mDateOnly) {
    const year = Number(mDateOnly[1])
    const month = Number(mDateOnly[2])
    const day = Number(mDateOnly[3])
    const d = new Date(year, month - 1, day)
    return Number.isNaN(d.getTime()) ? null : d
  }

  // Normalize "YYYY-MM-DD HH:MM" (or with seconds) to ISO-ish local time.
  // Safari is picky about space-separated timestamps.
  const normalized = raw.replace(
    /^(\d{4}-\d{2}-\d{2})\s+(\d{1,2}:\d{2}(?::\d{2})?)/,
    (_, date, time) => `${date}T${time}`
  )
  const parsed = new Date(normalized)
  return Number.isNaN(parsed.getTime()) ? null : parsed
}

function formatShortDate(date) {
  if (!date) return ''
  return `${date.getMonth() + 1}/${date.getDate()}`
}

function formatObsDateTime(obsDt) {
  const d = parseObsDate(obsDt)
  if (!d) return obsDt || 'Unknown date'
  const mo = d.getMonth() + 1
  const day = d.getDate()
  const h = d.getHours()
  const m = String(d.getMinutes()).padStart(2, '0')
  const ampm = h >= 12 ? 'pm' : 'am'
  const h12 = h % 12 || 12
  return `${mo}/${day} ${h12}:${m}${ampm}`
}

function dayOffsetFromToday(date) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const target = new Date(date)
  target.setHours(0, 0, 0, 0)
  return Math.round((today.getTime() - target.getTime()) / 86400000)
}

function getDateBubbleClass(kind, firstDate, lastDate) {
  const targetDate = kind === 'first' ? firstDate : lastDate
  const firstOffset = dayOffsetFromToday(firstDate)
  const lastOffset = dayOffsetFromToday(lastDate)
  if (firstOffset === 0 && lastOffset === 0) return 'date-bubble-red-new'
  const offset = dayOffsetFromToday(targetDate)
  if (offset === 0) return 'date-bubble-green-dark'
  if (offset === 1) return 'date-bubble-green-light'
  if (offset === 2) return 'date-bubble-yellow'
  return 'date-bubble-neutral'
}

function renderDateBubble(label, bubbleClass) {
  const text = String(label || '').trim()
  if (!text) return ''
  const cls = bubbleClass || 'date-bubble-neutral'
  return `<span class="date-bubble ${cls}">${escapeHtml(text)}</span>`
}

function renderAbaCodeBadge(code) {
  const n = Number(code)
  if (!Number.isFinite(n) || n < 1 || n > 6) {
    return '<span class="aba-code-badge aba-code-unknown" title="ABA code unavailable">N</span>'
  }
  const safe = Math.round(n)
  return `<span class="aba-code-badge aba-code-${safe}" title="ABA code ${safe}">${safe}</span>`
}

function renderYoloCodeBadge(species, abaCode) {
  const yoloInfo = getYoloSpeciesInfo(species)
  const yCode = Number(yoloInfo?.yoloCode)
  if (!Number.isFinite(yCode)) {
    return '<span class="yolo-code-badge yolo-code-none" title="No Yolo County code"></span>'
  }
  const diverges = Number.isFinite(abaCode) && yCode > abaCode
  const noteSuffix = yoloInfo?.notes ? ` · ${escapeHtml(String(yoloInfo.notes))}` : ''
  const marker = diverges ? ' yolo-diverges' : ''
  return `<span class="yolo-code-badge yolo-code-${yCode}${marker}" title="Yolo County code ${yCode}${diverges ? ' (rarer locally)' : ''}${noteSuffix}">${yCode}</span>`
}

function statusCodeClassSuffix(code) {
  return String(code || '').toLowerCase().replace(/[^a-z0-9]+/g, '-')
}

function renderSpeciesStatusBullets(species) {
  const info = getYoloSpeciesInfo(species)
  if (!info) return ''
  const uniqueCodes = Array.from(new Set([info.statusCode, info.avibaseStatusCode].filter(Boolean)))
  if (!uniqueCodes.length) return ''
  return uniqueCodes
    .map((code) => {
      const safeCode = escapeHtml(code)
      const cls = statusCodeClassSuffix(code)
      return `<span class="species-status-bullet status-code-${cls}" title="Reference status ${safeCode}">${safeCode}</span>`
    })
    .join('')
}

function isConfirmedObservation(item) {
  if (item && typeof item.confirmedAny === 'boolean') return item.confirmedAny
  return Number(item?.obsReviewed) === 1 && Number(item?.obsValid) === 1
}

function renderStatusDot(isConfirmed) {
  const cls = isConfirmed ? 'status-dot-confirmed' : 'status-dot-pending'
  const title = isConfirmed ? 'Confirmed' : 'Pending'
  return `<span class="status-dot ${cls}" title="${title}"></span>`
}

function getItemStateAbbrev(item) {
  const code = String(item?.subnational1Code || '')
  if (!code) return ''
  return code.includes('-') ? (code.split('-').pop() || '') : code
}

function getItemCountyName(item) {
  return String(item?.subnational2Name || item?.subnational2Code || '')
}

function buildGroupedRowsFromObservations(observations) {
  const grouped = new Map()
  ;(Array.isArray(observations) ? observations : []).forEach((item) => {
    const species = item.comName || ''
    const state = getItemStateAbbrev(item)
    const county = getItemCountyName(item)
    const countyRegion = String(item?.subnational2Code || '').toUpperCase() || null
    const key = `${species}::${state}::${county}`

    // Some endpoints return raw observations (obsDt per row). Others may return
    // already-aggregated rows with dedicated first/last fields.
    const firstCandidate = parseFirstAvailableObsDate(
      item?.firstObsDt,
      item?.firstObsDate,
      item?.firstDt,
      item?.first,
      item?.obsDt
    )
    const lastCandidate = parseFirstAvailableObsDate(
      item?.lastObsDt,
      item?.lastObsDate,
      item?.lastDt,
      item?.last,
      item?.obsDt
    )

    const abaCode = getAbaCodeNumber(item)
    const lat = Number(item.lat)
    const lng = Number(item.lng)

    const explicitCount = Number(item?.count ?? item?.numObs ?? item?.numObservations)
    const increment = Number.isFinite(explicitCount) ? Math.max(1, Math.round(explicitCount)) : 1

    if (!grouped.has(key)) {
      grouped.set(key, {
        groupKey: key,
        species,
        state,
        county,
        countyRegion,
        count: 0,
        first: firstCandidate,
        last: lastCandidate,
        abaCode,
        confirmedAny: isConfirmedObservation(item),
        lat: Number.isFinite(lat) ? lat : null,
        lng: Number.isFinite(lng) ? lng : null,
        distanceKm: null,
      })
    }

    const entry = grouped.get(key)
    entry.count += increment
    entry.confirmedAny = entry.confirmedAny || isConfirmedObservation(item)
    if (abaCode !== null) {
      if (entry.abaCode === null || entry.abaCode === undefined || abaCode > entry.abaCode) {
        entry.abaCode = abaCode
      }
    }

    if (firstCandidate) {
      if (!entry.first || firstCandidate < entry.first) entry.first = firstCandidate
    }
    if (lastCandidate) {
      if (!entry.last || lastCandidate > entry.last) entry.last = lastCandidate
    }
  })

  return grouped
}

function renderNotableTable(observations, countyName, regionCode, abaPillObservations = observations) {
  setTableRenderStatus('table-start')
  lastTableObservationSource = Array.isArray(observations) ? observations : []
  notableRows.innerHTML = ''
  const previousRegion = String(notableMeta?.dataset?.regionCode || '').toUpperCase()
  notableMeta.textContent = `${countyName || 'County'} · ${regionCode || ''}`.trim()
  notableMeta.dataset.regionCode = regionCode || ''

  const normalizedRegion = String(regionCode || '').toUpperCase()
  const isStateRegion = /^US-[A-Z]{2}$/.test(normalizedRegion)
  const isUsRegion = normalizedRegion === US_REGION_CODE
  if (isUsRegion) {
    renderStateCountySummaryTable(observations, countyName, normalizedRegion, abaPillObservations)
    return
  }

  // For state selection, render the normal species table (same as county mode)
  // but sort by distance from the user's county (fallback: GPS / map center).
  const stateDistanceAnchor = isStateRegion ? getDistanceAnchorPoint() : null

  const abaPillGrouped = buildGroupedRowsFromObservations(abaPillObservations)

  if (!Array.isArray(observations) || observations.length === 0) {
    notableCount.className = 'badge ok'
    notableCount.textContent = '0'
    updateStatPills('0', '0', '0')
    renderAbaStatPills(Array.from(abaPillGrouped.values()))
    const activeAba = (selectedAbaCodes instanceof Set && selectedAbaCodes.size > 0)
      ? Array.from(selectedAbaCodes)[0]
      : null
    const days = Math.max(1, Math.min(14, Number(filterDaysBack) || 7))
    const emptyMessage = activeAba
      ? `No records for ABA ${activeAba} species in past ${days} days.`
      : isStateRegion
        ? 'No notable observations found for this state.'
        : 'No notable observations found for this county.'
    notableRows.innerHTML = `<tr><td colspan="7">${emptyMessage}</td></tr>`
    setTableRenderStatus('table-empty')
    return
  }

  // Group by species+county (matching desktop renderSightingsTable)
  const grouped = buildGroupedRowsFromObservations(observations)

  // Make distance-based sorting available in any view where we have an anchor.
  const distanceAnchor = getDistanceAnchorPoint()
  if (distanceAnchor && Number.isFinite(distanceAnchor.lat) && Number.isFinite(distanceAnchor.lng)) {
    const closestByKey = computeClosestPointByGroup(observations, distanceAnchor.lat, distanceAnchor.lng)
    grouped.forEach((row) => {
      const closest = closestByKey.get(row.groupKey)
      if (closest) {
        row.distanceKm = closest.distanceKm
        row.lat = closest.lat
        row.lng = closest.lng
      }
    })
  }

  // Default county-mode sort: ABA descending, then state/county/date.
  // State-mode sort: nearest first (distance), then ABA desc, then last desc.
  let sorted = Array.from(grouped.values())
  if (isStateRegion && stateDistanceAnchor) {
    sorted.forEach((row) => {
      if (!Number.isFinite(row.distanceKm)) row.distanceKm = Infinity
    })
    sorted = sorted
      .filter((row) => Number.isFinite(row.distanceKm))
      .sort((a, b) => {
        const aDist = Number.isFinite(a.distanceKm) ? a.distanceKm : Infinity
        const bDist = Number.isFinite(b.distanceKm) ? b.distanceKm : Infinity
        if (aDist !== bDist) return aDist - bDist
        const aCode = Number.isFinite(a.abaCode) ? a.abaCode : -1
        const bCode = Number.isFinite(b.abaCode) ? b.abaCode : -1
        if (aCode !== bCode) return bCode - aCode
        const aLast = a.last ? a.last.getTime() : 0
        const bLast = b.last ? b.last.getTime() : 0
        if (aLast !== bLast) return bLast - aLast
        return String(a.species || '').localeCompare(String(b.species || ''))
      })

    // Default to distance sort when entering state mode.
    if (!/^US-[A-Z]{2}$/.test(previousRegion) && sortState.col !== 'distance') {
      sortState = { col: 'distance', dir: 'asc' }
    }
    notableMeta.textContent = `${countyName || normalizedRegion} · ${normalizedRegion}`
  } else {
    sorted = sorted.sort((a, b) => {
      const aCode = Number.isFinite(a.abaCode) ? a.abaCode : -1
      const bCode = Number.isFinite(b.abaCode) ? b.abaCode : -1
      if (aCode !== bCode) return bCode - aCode
      const aState = String(a.state || '').toLowerCase()
      const bState = String(b.state || '').toLowerCase()
      if (aState !== bState) return aState.localeCompare(bState)
      const aCounty = String(a.county || '').toLowerCase()
      const bCounty = String(b.county || '').toLowerCase()
      if (aCounty !== bCounty) return aCounty.localeCompare(bCounty)
      return (b.last ? b.last.getTime() : 0) - (a.last ? a.last.getTime() : 0)
    })
  }

  notableCount.className = 'badge ok'
  notableCount.textContent = String(sorted.length)
  const confirmedCount = sorted.filter((r) => r.confirmedAny).length
  updateStatPills(sorted.length, confirmedCount, sorted.length - confirmedCount)
  renderAbaStatPills(Array.from(abaPillGrouped.values()))
  currentTableData = sorted
  applySortAndRender()
}

function buildStateCountySummaryRows(observations, stateRegion) {
  const normalizedState = String(stateRegion || '').toUpperCase()
  const isUS = normalizedState === US_REGION_CODE
  const source = Array.isArray(observations) ? observations : []
  const buckets = new Map()

  source.forEach((item) => {
    const itemState = String(item?.subnational1Code || '').toUpperCase()
    if (!isUS && /^US-[A-Z]{2}$/.test(normalizedState) && itemState !== normalizedState) return

    const regionKey = isUS ? itemState : String(item?.subnational2Code || '').toUpperCase()
    if (!isUS && !/^US-[A-Z]{2}-\d{3}$/.test(regionKey)) return
    if (isUS && !/^US-[A-Z]{2}$/.test(regionKey)) return

    if (!buckets.has(regionKey)) {
      let regionName = regionKey
      if (isUS) {
        const stateObj = LOWER_48_STATES.find(s => s.code === regionKey)
        if (stateObj) regionName = stateObj.name
      } else {
        regionName = String(item?.subnational2Name || regionKey)
      }
      buckets.set(regionKey, {
        countyRegion: regionKey,
        countyName: regionName,
        observations: [],
      })
    }
    buckets.get(regionKey).observations.push(item)
  })

  const rows = Array.from(buckets.values()).map((bucket) => {
    const groupedRows = Array.from(buildGroupedRowsFromObservations(bucket.observations).values())
    const summary = summarizeCountyObservations(bucket.observations)
    const confirmedCount = groupedRows.filter((row) => row.confirmedAny).length
    const pendingCount = Math.max(0, summary.rarityCount - confirmedCount)
    const latestDate = bucket.observations.reduce((latest, item) => {
      const parsed = parseFirstAvailableObsDate(item?.lastObsDt, item?.lastObsDate, item?.lastDt, item?.last, item?.obsDt)
      if (!parsed) return latest
      if (!latest || parsed > latest) return parsed
      return latest
    }, null)
    const firstDate = bucket.observations.reduce((first, item) => {
      const parsed = parseFirstAvailableObsDate(item?.firstObsDt, item?.firstObsDate, item?.firstDt, item?.first, item?.obsDt)
      if (!parsed) return first
      if (!first || parsed < first) return parsed
      return first
    }, null)

    const pickerOption = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === bucket.countyRegion)
    const lat = Number(pickerOption?.lat)
    const lng = Number(pickerOption?.lng)

    return {
      countyRegion: bucket.countyRegion,
      countyName: bucket.countyName,
      summary,
      rarityCount: summary.rarityCount,
      confirmedCount,
      pendingCount,
      last: latestDate,
      first: firstDate,
      lat: Number.isFinite(lat) ? lat : null,
      lng: Number.isFinite(lng) ? lng : null,
      distanceKm: null,
    }
  })

  // If we're in a state (not US) view, sort counties by distance from the user's county (fallback: GPS).
  const anchorLat = Number.isFinite(lastCountyAnchorLat) ? lastCountyAnchorLat : (Number.isFinite(lastUserLat) ? lastUserLat : null)
  const anchorLng = Number.isFinite(lastCountyAnchorLng) ? lastCountyAnchorLng : (Number.isFinite(lastUserLng) ? lastUserLng : null)
  const hasAnchor = !isUS && Number.isFinite(anchorLat) && Number.isFinite(anchorLng)
  if (hasAnchor) {
    rows.forEach((row) => {
      if (Number.isFinite(row.lat) && Number.isFinite(row.lng)) {
        row.distanceKm = distanceKm(anchorLat, anchorLng, row.lat, row.lng)
      } else {
        row.distanceKm = Infinity
      }
    })
    rows.sort((a, b) => {
      if (a.distanceKm !== b.distanceKm) return a.distanceKm - b.distanceKm
      if (b.rarityCount !== a.rarityCount) return b.rarityCount - a.rarityCount
      return a.countyName.localeCompare(b.countyName)
    })
  } else {
    rows.sort((a, b) => {
      if (b.rarityCount !== a.rarityCount) return b.rarityCount - a.rarityCount
      return a.countyName.localeCompare(b.countyName)
    })
  }

  return rows
}

function renderStateCountySummaryTable(observations, countyName, stateRegion, abaPillObservations = observations) {
  const stateRows = buildStateCountySummaryRows(observations, stateRegion)
  const isUS = String(stateRegion || '').toUpperCase() === US_REGION_CODE
  notableMeta.textContent = `${countyName || stateRegion} · ${isUS ? 'state summaries' : 'county summaries'}`
  notableMeta.dataset.regionCode = stateRegion || ''

  const abaPillGrouped = buildGroupedRowsFromObservations(abaPillObservations)
  renderAbaStatPills(Array.from(abaPillGrouped.values()))

  if (!stateRows.length) {
    notableCount.className = 'badge ok'
    notableCount.textContent = '0'
    updateStatPills('0', '0', '0')
    notableRows.innerHTML = `<tr><td colspan="7">No ${isUS ? 'state' : 'county'} summaries found for this region and filter set.</td></tr>`
    currentTableData = []
    setTableRenderStatus('state-summary-empty')
    return
  }

  const totalRarities = stateRows.reduce((sum, row) => sum + row.rarityCount, 0)
  const confirmedRarities = stateRows.reduce((sum, row) => sum + row.confirmedCount, 0)
  const pendingRarities = Math.max(0, totalRarities - confirmedRarities)

  notableCount.className = 'badge ok'
  notableCount.textContent = String(stateRows.length)
  updateStatPills(totalRarities, confirmedRarities, pendingRarities)

  const fragment = document.createDocumentFragment()
  stateRows.forEach((row) => {
    const lastBubble = renderDateBubble(formatShortDate(row.last), getDateBubbleClass('last', row.first, row.last))
    const firstBubble = renderDateBubble(formatShortDate(row.first), getDateBubbleClass('first', row.first, row.last))
    const isConfirmed = row.confirmedCount > 0
    const countPill = `<span class="count-pill ${isConfirmed ? 'count-pill-confirmed' : 'count-pill-pending'}" title="${isConfirmed ? 'Confirmed' : 'Pending'}">${row.rarityCount}</span>`
    const pinHtml = (row.lat != null && row.lng != null)
      ? `<button type="button" class="row-pin-btn" data-lat="${row.lat}" data-lng="${row.lng}" title="Open in Google Maps">📍</button>`
      : ''

    const tableRow = document.createElement('tr')
    tableRow.dataset.countyRegion = String(row.countyRegion || '').toUpperCase()
    tableRow.dataset.county = String(row.countyName || '')
    tableRow.innerHTML = `
      <td><div class="species-cell"><button type="button" class="county-summary-btn" data-county-region="${escapeHtml(row.countyRegion)}">${escapeHtml(row.countyName)}</button><span class="county-option-meta">${escapeHtml(formatCountySummary(row.summary))}</span></div></td>
      <td class="col-county"></td>
      <td class="col-date col-last">${lastBubble}</td>
      <td class="col-date col-first">${firstBubble}</td>
      <td class="col-reports">${countPill}</td>
      <td class="col-vis"></td>
      <td class="col-pin">${pinHtml}</td>
    `
    fragment.appendChild(tableRow)
  })

  notableRows.innerHTML = ''
  notableRows.appendChild(fragment)
  currentTableData = []
  setTableRenderStatus(`state-summary rows=${stateRows.length}`)
}

function applySortAndRender() {
  if (!currentTableData.length) return
  const { col, dir } = sortState

  const regionCode = document.querySelector('#notableMeta')?.dataset?.regionCode || ''
  const isYolo = regionCode === 'US-CA-113'

  const getPreferredCode = (row) => {
    if (isYolo) {
      const yoloInfo = getYoloSpeciesInfo(row?.species)
      const yoloCode = Number(yoloInfo?.yoloCode)
      if (Number.isFinite(yoloCode)) return Math.round(yoloCode)
    }
    const aba = Number(row?.abaCode)
    return Number.isFinite(aba) ? Math.round(aba) : -1
  }

  const usePinning = col !== 'distance'
  const pinnedCandidate = String(activeSortCountyRegion || '').toUpperCase()
  const pinnedRegion = (usePinning && isCountyRegionCode(pinnedCandidate) && currentTableData.some((r) => String(r?.countyRegion || '').toUpperCase() === pinnedCandidate))
    ? pinnedCandidate
    : (usePinning && currentTableData.some((r) => String(r?.countyRegion || '').toUpperCase() === YOLO_COUNTY_REGION) ? YOLO_COUNTY_REGION : '')

  const data = [...currentTableData].sort((a, b) => {
    if (pinnedSpecies) {
      const aPinnedSpecies = String(a?.species || '') === pinnedSpecies
      const bPinnedSpecies = String(b?.species || '') === pinnedSpecies
      if (aPinnedSpecies !== bPinnedSpecies) return aPinnedSpecies ? -1 : 1
    }

    const aRegion = String(a?.countyRegion || '').toUpperCase()
    const bRegion = String(b?.countyRegion || '').toUpperCase()
    if (pinnedRegion) {
      const aPinned = aRegion === pinnedRegion
      const bPinned = bRegion === pinnedRegion
      if (aPinned !== bPinned) return aPinned ? -1 : 1
    }

    const aCode = getPreferredCode(a)
    const bCode = getPreferredCode(b)
    const aLast = a.last?.getTime() ?? 0
    const bLast = b.last?.getTime() ?? 0

    if (col === 'distance') {
      const aDist = Number.isFinite(a.distanceKm) ? a.distanceKm : Infinity
      const bDist = Number.isFinite(b.distanceKm) ? b.distanceKm : Infinity
      if (aDist !== bDist) return dir === 'desc' ? (bDist - aDist) : (aDist - bDist)
      // Distance mode tie-breakers: code desc, then last desc.
      if (aCode !== bCode) return bCode - aCode
      if (aLast !== bLast) return bLast - aLast
      return String(a.species || '').localeCompare(String(b.species || ''))
    }

    if (col === 'aba') {
      if (aCode !== bCode) return dir === 'desc' ? (bCode - aCode) : (aCode - bCode)
      if (aLast !== bLast) return bLast - aLast
      return String(a.species || '').localeCompare(String(b.species || ''))
    }

    const aDate = (col === 'last' ? a.last : a.first)?.getTime() ?? 0
    const bDate = (col === 'last' ? b.last : b.first)?.getTime() ?? 0
    if (aDate !== bDate) return dir === 'desc' ? (bDate - aDate) : (aDate - bDate)

    // Tiebreakers: ABA desc, then Last desc
    if (aCode !== bCode) return bCode - aCode
    if (aLast !== bLast) return bLast - aLast
    return String(a.species || '').localeCompare(String(b.species || ''))
  })
  const fragment = document.createDocumentFragment()
  data.forEach((item) => {
    const lastBubble = renderDateBubble(formatShortDate(item.last), getDateBubbleClass('last', item.first, item.last))
    const firstBubble = renderDateBubble(formatShortDate(item.first), getDateBubbleClass('first', item.first, item.last))
    const abaBadge = renderAbaCodeBadge(item.abaCode)
    const yoloBadge = isYolo ? renderYoloCodeBadge(item.species, item.abaCode) : ''
    const statusBullets = isYolo ? renderSpeciesStatusBullets(item.species) : ''
    const isConfirmed = Boolean(item.confirmedAny)
    const countPill = `<span class="count-pill ${isConfirmed ? 'count-pill-confirmed' : 'count-pill-pending'}" title="${isConfirmed ? 'Confirmed' : 'Pending'}">${item.count}</span>`
    const isChecked = !hiddenSpecies.has(item.species)
    const pinHtml = (item.lat != null && item.lng != null)
      ? `<button type="button" class="row-pin-btn" data-lat="${item.lat}" data-lng="${item.lng}" title="Open in Google Maps">📍</button>`
      : ''
    const row = document.createElement('tr')
    const safeSpecies = escapeHtml(item.species)
    const safeCountyFull = escapeHtml(String(item.county || ''))
    const safeCountyShort = escapeHtml(shortCountyName(item.county))
    row.dataset.species = item.species
    row.dataset.county = String(item.county || '')
    row.dataset.countyRegion = String(item.countyRegion || '').toUpperCase()
    row.innerHTML = `
      <td><div class="species-cell">${abaBadge}${yoloBadge}${statusBullets}<button type="button" class="species-btn" data-species="${safeSpecies}">${safeSpecies}</button></div></td>
      <td class="col-county"><span class="county-cell" title="${safeCountyFull}">${safeCountyShort}</span></td>
      <td class="col-date col-last">${lastBubble}</td>
      <td class="col-date col-first">${firstBubble}</td>
      <td class="col-reports">${countPill}</td>
      <td class="col-vis"><input type="checkbox" class="obs-vis-cb" data-species="${safeSpecies}" ${isChecked ? 'checked' : ''}></td>
      <td class="col-pin">${pinHtml}</td>
    `
    fragment.appendChild(row)
  })
  notableRows.innerHTML = ''
  notableRows.appendChild(fragment)
  // Re-sync toggle-all
  const toggleAll = document.querySelector('#toggleAllVis')
  if (toggleAll) {
    if (hiddenSpecies.size === 0) { toggleAll.checked = true; toggleAll.indeterminate = false }
    else if (hiddenSpecies.size >= currentTableData.length) { toggleAll.checked = false; toggleAll.indeterminate = false }
    else { toggleAll.indeterminate = true }
  }
  // Update sort icons
  ;['thSpecies', 'thLast', 'thFirst'].forEach((id) => {
    const th = document.querySelector(`#${id}`)
    if (!th) return
    const colMap = { thSpecies: 'aba', thLast: 'last', thFirst: 'first' }
    const icon = th.querySelector('.sort-icon')
    if (!icon) return
    if (colMap[id] === col) {
      icon.textContent = dir === 'desc' ? ' ↓' : ' ↑'
      th.classList.add('sort-active')
    } else {
      icon.textContent = ''
      th.classList.remove('sort-active')
    }
  })
  updateSortModeBtnUi()
  setTableRenderStatus(`sorted:${col}:${dir} rows=${data.length}`)
}

function updateSortModeBtnUi() {
  if (!sortModeBtn) return
  const isDistance = sortState?.col === 'distance'
  const label = sortModeBtn.querySelector('.sort-toggle-label')
  if (label) label.textContent = isDistance ? 'distance' : 'ABA'
  sortModeBtn.setAttribute('aria-pressed', isDistance ? 'true' : 'false')
  sortModeBtn.classList.toggle('is-active', isDistance)
  sortModeBtn.title = isDistance
    ? 'Sort: Distance (tap for ABA)'
    : 'Sort: ABA (tap for distance)'
}

function ensureDistanceKmForCurrentTableData() {
  if (!Array.isArray(currentTableData) || currentTableData.length === 0) return
  const anchor = getDistanceAnchorPoint()
  if (!anchor || !Number.isFinite(anchor.lat) || !Number.isFinite(anchor.lng)) return

  const closestByKey = computeClosestPointByGroup(lastTableObservationSource, anchor.lat, anchor.lng)
  currentTableData.forEach((row) => {
    const closest = closestByKey.get(row.groupKey)
    if (closest) {
      row.distanceKm = closest.distanceKm
      row.lat = closest.lat
      row.lng = closest.lng
      return
    }
    if (Number.isFinite(row.lat) && Number.isFinite(row.lng)) {
      row.distanceKm = distanceKm(anchor.lat, anchor.lng, row.lat, row.lng)
    } else {
      row.distanceKm = Infinity
    }
  })
}

function setActiveSortCountyRegion(nextRegion) {
  const normalized = String(nextRegion || '').toUpperCase()
  if (!isCountyRegionCode(normalized)) return
  activeSortCountyRegion = normalized
  applySortAndRender()
}

// ---------------------------------------------------------------------------
// Fast canvas overlay — replaces per-marker Leaflet objects with a single
// Canvas2D draw pass + one click-handler for hit-testing.
// ---------------------------------------------------------------------------
const ABA_COLORS = {
  1: { fill: '#067bc2', border: '#ffffff' },
  2: { fill: '#84bcda', border: '#ffffff' },
  3: { fill: '#ecc30b', border: '#ffffff' },
  4: { fill: '#f37748', border: '#ffffff' },
  5: { fill: '#ED1313', border: '#ffffff' },
  6: { fill: '#ed13d4', border: '#ffffff' },
}
const ABA_DEFAULT_COLOR = { fill: '#4b5563', border: '#ffffff' }
const MARKER_RADIUS = 9        // px, logical
const HIT_RADIUS = 12          // px, slightly larger for touch
const CLUSTER_ZOOM_THRESHOLD = 10
const CLUSTER_GRID_PX = 44

let fastCanvasOverlay = null   // L.Layer instance
let fastCanvasData = []        // rendered points for current zoom (clustered or raw)
let fastCanvasBaseData = []    // raw points before clustering
let fastCanvasPopup = null     // single reused L.popup
let fastCanvasPopupKey = null  // key for last opened popup (for toggle close)

function getCanvasPopupKey(pt) {
  if (!pt) return ''
  const species = String(pt.species || '')
  const lat = Number(pt.lat)
  const lng = Number(pt.lng)
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return species
  return `${species}|${lat.toFixed(5)}|${lng.toFixed(5)}`
}

function buildClusteredCanvasData(baseData, mapInstance) {
  if (!mapInstance) return Array.isArray(baseData) ? baseData : []
  const source = Array.isArray(baseData) ? baseData : []
  if (!source.length) return []
  if (mapInstance.getZoom() > CLUSTER_ZOOM_THRESHOLD) return source

  const buckets = new Map()
  source.forEach((pt) => {
    if (pt.hidden) return
    const cp = mapInstance.latLngToContainerPoint([pt.lat, pt.lng])
    const key = `${Math.round(cp.x / CLUSTER_GRID_PX)}:${Math.round(cp.y / CLUSTER_GRID_PX)}`
    if (!buckets.has(key)) {
      buckets.set(key, {
        points: [],
        latSum: 0,
        lngSum: 0,
        maxAbaCode: Number.isFinite(pt.abaCode) ? pt.abaCode : null,
      })
    }
    const bucket = buckets.get(key)
    bucket.points.push(pt)
    bucket.latSum += pt.lat
    bucket.lngSum += pt.lng
    if (Number.isFinite(pt.abaCode) && (!Number.isFinite(bucket.maxAbaCode) || pt.abaCode > bucket.maxAbaCode)) {
      bucket.maxAbaCode = pt.abaCode
    }
  })

  const clustered = []
  buckets.forEach((bucket) => {
    if (bucket.points.length === 1) {
      clustered.push(bucket.points[0])
      return
    }
    const abaCode = Number.isFinite(bucket.maxAbaCode) ? bucket.maxAbaCode : null
    const colors = ABA_COLORS[abaCode] || ABA_DEFAULT_COLOR
    const count = bucket.points.length
    clustered.push({
      lat: bucket.latSum / count,
      lng: bucket.lngSum / count,
      fill: colors.fill,
      border: colors.border,
      species: `${count} observations`,
      safeSpecies: escapeHtml(`${count} observations`),
      abaCode,
      subIds: [],
      subDates: [],
      item: bucket.points[0]?.item || null,
      label: String(count),
      hidden: false,
      isCluster: true,
      clusterCount: count,
    })
  })

  return clustered
}

function buildFastCanvasOverlay() {
  const CanvasOverlay = L.Layer.extend({
    onAdd(m) {
      this._map = m
      this._canvas = document.createElement('canvas')
      this._canvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none'
      m.getPanes().notablePane.appendChild(this._canvas)
      m.on('move zoomend resize', this._redraw, this)
      this._redraw()
    },
    onRemove(m) {
      m.off('move zoomend resize', this._redraw, this)
      this._canvas.remove()
    },
    redraw() { this._redraw() },
    _redraw() {
      const m = this._map
      const size = m.getSize()
      const dpr = window.devicePixelRatio || 1
      const cvs = this._canvas
      cvs.width  = size.x * dpr
      cvs.height = size.y * dpr
      cvs.style.width  = size.x + 'px'
      cvs.style.height = size.y + 'px'

      // Align canvas top-left with the map's current tile origin
      const topLeft = m.containerPointToLayerPoint([0, 0])
      L.DomUtil.setPosition(cvs, topLeft)

      const ctx = cvs.getContext('2d')
      ctx.scale(dpr, dpr)
      ctx.clearRect(0, 0, size.x, size.y)

      const drawData = buildClusteredCanvasData(fastCanvasBaseData, m)
      fastCanvasData = drawData
      for (const pt of drawData) {
        if (pt.hidden) continue
        const r = pt.isCluster ? Math.min(17, MARKER_RADIUS + Math.floor(Math.log2((pt.clusterCount || 1) + 1)) * 2) : MARKER_RADIUS
        // Use layer-space coordinates so canvas positioning and point math
        // stay in the same reference frame during pan/zoom transforms.
        const lp = m.latLngToLayerPoint([pt.lat, pt.lng])
        const x = lp.x - topLeft.x
        const y = lp.y - topLeft.y
        ctx.beginPath()
        ctx.arc(x, y, r, 0, Math.PI * 2)
        ctx.fillStyle = pt.fill
        ctx.fill()
        ctx.lineWidth = 1.5
        ctx.strokeStyle = pt.border
        ctx.stroke()
        if (pt.isCluster) {
          if (labelMode !== 'off') {
            const txt = String(pt.clusterCount || '')
            ctx.font = '700 10px sans-serif'
            ctx.textAlign = 'center'
            ctx.textBaseline = 'middle'
            ctx.fillStyle = '#ffffff'
            ctx.fillText(txt, x, y)
          }
          continue
        }
        if (pt.label) {
          ctx.font = '600 11px sans-serif'
          ctx.textAlign = 'left'
          ctx.textBaseline = 'alphabetic'
          const tx = x + r + 4
          const ty = y + 4
          const tw = ctx.measureText(pt.label).width
          const pad = 2
          ctx.fillStyle = 'rgba(255,255,255,0.82)'
          ctx.beginPath()
          ctx.roundRect(tx - pad, ty - 10, tw + pad * 2, 13, 3)
          ctx.fill()
          ctx.fillStyle = '#0f172a'
          ctx.fillText(pt.label, tx, ty)
        }
      }
    },
  })
  return new CanvasOverlay()
}

function hitTestCanvas(containerPoint) {
  const m = map
  let best = null
  let bestDist = Infinity
  for (const pt of fastCanvasData) {
    if (pt.hidden) continue
    const cp = m.latLngToContainerPoint([pt.lat, pt.lng])
    const dx = cp.x - containerPoint.x
    const dy = cp.y - containerPoint.y
    const hitRadius = pt.isCluster ? 18 : HIT_RADIUS
    const r2 = hitRadius * hitRadius
    const d2 = dx * dx + dy * dy
    if (d2 <= r2 && d2 < bestDist) {
      best = pt
      bestDist = d2
    }
  }
  return best
}

function buildObservationPopupHtml(pt) {
  if (!pt) return ''
  const item = pt.item
  const locId = item?.locId ? String(item.locId) : null
  const locName = item?.locName ? String(item.locName) : ''
  const abaBadge = renderAbaCodeBadge(pt.abaCode)
  const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(`${pt.lat},${pt.lng}`)}`
  const speciesEl = `<span class="obs-popup-species">${pt.safeSpecies}</span>`
  const header = `<div class="obs-popup-header">${abaBadge}${speciesEl}<a class="obs-popup-mapit" href="${mapsUrl}" target="_blank" rel="noopener" title="Map it">&#x1F4CD;</a></div>`

  const countyRaw = item?.subnational2Name ? String(item.subnational2Name) : ''
  const stateRaw = item?.subnational1Code ? String(item.subnational1Code) : ''
  const stateAbbrev = stateRaw.toUpperCase().startsWith('US-') ? stateRaw.toUpperCase().slice(3) : stateRaw.toUpperCase()
  let countyDisplay = countyRaw.trim()
  if (countyDisplay && !/county\s*$/i.test(countyDisplay)) countyDisplay = `${countyDisplay} County`
  const countyStateLine = (countyDisplay && stateAbbrev)
    ? `<div class="obs-popup-county">${escapeHtml(`${countyDisplay}, ${stateAbbrev}`)}</div>`
    : ''

  const locationLine = locName
    ? (locId
      ? `<a class="obs-popup-location" href="https://ebird.org/hotspot/${encodeURIComponent(locId)}" target="_blank" rel="noopener" title="${escapeHtml(locName)}">${escapeHtml(locName)}</a>`
      : `<div class="obs-popup-location" title="${escapeHtml(locName)}">${escapeHtml(locName)}</div>`)
    : ''

  const checklistItems = (pt.subIds || []).map((sid, i) => {
    const label = formatObsDateTime(pt.subDates?.[i])
    return `<li><a href="https://ebird.org/checklist/${encodeURIComponent(sid)}" target="_blank" rel="noopener">${escapeHtml(label)}</a></li>`
  })
  const checklistSection = checklistItems.length
    ? `<ul class="obs-popup-checklist">${checklistItems.join('')}</ul>`
    : ''

  return `<div class="obs-popup-inner">${header}${countyStateLine}${locationLine}${checklistSection}</div>`
}

function openObservationPopup(pt) {
  if (!map || !pt) return
  const html = buildObservationPopupHtml(pt)
  if (!html) return
  if (!fastCanvasPopup) fastCanvasPopup = L.popup({ maxWidth: 180, className: 'obs-popup' })
  fastCanvasPopupKey = getCanvasPopupKey(pt)
  fastCanvasPopup.setLatLng([pt.lat, pt.lng]).setContent(html).openOn(map)
}

function pickBestSpeciesPoint(points) {
  if (!Array.isArray(points) || points.length === 0) return null
  if (points.length === 1) return points[0]
  const toMs = (pt) => {
    const list = Array.isArray(pt?.subDates) ? pt.subDates : []
    let best = 0
    list.forEach((raw) => {
      const parsed = parseObsDate(raw)
      const ms = parsed ? parsed.getTime() : 0
      if (ms > best) best = ms
    })
    return best
  }
  return points.reduce((best, current) => (toMs(current) > toMs(best) ? current : best), points[0])
}

// Install a single map click handler once
let _canvasClickInstalled = false
function ensureCanvasClickHandler() {
  if (_canvasClickInstalled) return
  _canvasClickInstalled = true
  // We listen on the map container directly so we get clicks through the canvas
  document.querySelector('#map')?.addEventListener('click', (e) => {
    if (!map) return
    const rect = map.getContainer().getBoundingClientRect()
    const cp = L.point(e.clientX - rect.left, e.clientY - rect.top)
    let pt = null
    if (fastCanvasData.length > 0) {
      pt = hitTestCanvas(cp)
      if (pt) {
        if (pt.isCluster && map) {
          const nextZoom = Math.max(map.getZoom() + 2, CLUSTER_ZOOM_THRESHOLD + 1)
          map.setView([pt.lat, pt.lng], nextZoom, { animate: true })
          return
        }
        e.stopPropagation()
        const key = getCanvasPopupKey(pt)
        if (key && fastCanvasPopup && fastCanvasPopupKey === key) {
          fastCanvasPopup.remove()
          fastCanvasPopup = null
          fastCanvasPopupKey = null
          return
        }
        openObservationPopup(pt)
        return
      }
    }

    const latlng = map.containerPointToLatLng(cp)
    const neighborFeature = findNeighborCountyFeatureAtLatLng(latlng.lat, latlng.lng)
    if (neighborFeature) {
      const region = String(neighborFeature?.properties?.countyRegion || neighborFeature?.properties?.subnational2Code || '').toUpperCase() || null
      const name = neighborFeature?.properties?.countyName || neighborFeature?.properties?.NAME || neighborFeature?.properties?.name || ''
      if (fastCanvasPopup) { fastCanvasPopup.remove(); fastCanvasPopup = null }
      fastCanvasPopupKey = null
      switchCountyFromMapTap(region, latlng.lat, latlng.lng, name, 'canvas-fallback')
      return
    }

    if (fastCanvasPopup) { fastCanvasPopup.remove(); fastCanvasPopup = null }
    fastCanvasPopupKey = null
  })
}
// ---------------------------------------------------------------------------

function renderNotablesOnMap(observations, activeCountyCode = '', fitToObservations = false) {
  initializeMap()
  perfStart('map')

  const renderId = ++latestMapRenderId

  const totalPoints = Array.isArray(observations) ? observations.length : 0
  const showPermanentLabels = labelMode !== 'off' && totalPoints <= MAP_LABEL_MAX_POINTS

  // Deduplicate: one canvas point per species×location, but collect ALL subIds
  const seenMap = new Map()  // key → deduped entry index
  const deduped = []
  if (Array.isArray(observations)) {
    for (const item of observations) {
      const lat = Number(item?.lat)
      const lng = Number(item?.lng)
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue
      const species = String(item?.comName || 'Unknown species')
      const key = `${species}|${lat.toFixed(4)}|${lng.toFixed(4)}`
      const subId = item?.subId ? String(item.subId) : null
      const obsDt = item?.obsDt ? String(item.obsDt) : null
      if (!seenMap.has(key)) {
        const entry = { item, lat, lng, species, subIds: subId ? [subId] : [], subDates: obsDt ? [obsDt] : [] }
        seenMap.set(key, deduped.length)
        deduped.push(entry)
      } else if (subId) {
        const existing = deduped[seenMap.get(key)]
        if (!existing.subIds.includes(subId)) {
          existing.subIds.push(subId)
          existing.subDates.push(obsDt)
        }
      }
    }
  }

  // Signature dedup — skip if nothing changed and we're not force-fitting
  let signatureHash = 0
  for (const { lat, lng, item } of deduped) {
    const code = getAbaCodeNumber(item) || 0
    signatureHash = ((signatureHash * 33) ^ (Math.round(lat * 10000) + Math.round(lng * 10000) + code)) >>> 0
  }
  const renderSignature = `${activeCountyCode}|${deduped.length}|${signatureHash}|${labelMode}`
  if (!fitToObservations && renderSignature === lastMapRenderSignature) {
    perfEnd('map')
    return
  }
  lastMapRenderSignature = renderSignature

  // Build lightweight data objects — no Leaflet marker construction
  const nextData = []
  const nextSpeciesMap = new Map()  // species → [{lat,lng}] for table row highlight
  for (const { item, lat, lng, species, subIds, subDates } of deduped) {
    const resolvedAba = getAbaCodeNumber(item)
    const abaCode = Number.isFinite(resolvedAba) ? resolvedAba : null
    const colors = ABA_COLORS[abaCode] || ABA_DEFAULT_COLOR
    const safeSpecies = escapeHtml(species)
    const itemCounty = String(item?.subnational2Code || '').toUpperCase()
    const isInActiveCounty = !activeCountyCode || itemCounty === activeCountyCode
    const label = (isInActiveCounty && showPermanentLabels) ? (labelMode === 'abbr' ? getSpeciesMapLabel(species) : species) : null
    const pt = { lat, lng, fill: colors.fill, border: colors.border, species, safeSpecies, abaCode, subIds, subDates, item, label, hidden: false }
    nextData.push(pt)
    if (!nextSpeciesMap.has(species)) nextSpeciesMap.set(species, [])
    nextSpeciesMap.get(species).push(pt)
  }

  if (renderId !== latestMapRenderId) { perfEnd('map'); return }

  // Swap in new data and redraw the single canvas layer
  fastCanvasBaseData = nextData
  fastCanvasData = nextData
  speciesMarkers = nextSpeciesMap   // reuse same variable — callers key on species name
  hiddenSpecies = new Set()
  const toggleAllEl = document.querySelector('#toggleAllVis')
  if (toggleAllEl) { toggleAllEl.checked = true; toggleAllEl.indeterminate = false }

  if (!fastCanvasOverlay) {
    fastCanvasOverlay = buildFastCanvasOverlay()
    fastCanvasOverlay.addTo(map)
    ensureCanvasClickHandler()
  } else {
    fastCanvasOverlay.redraw()
  }

  // Remove old Leaflet featureGroup layer if present from a previous render
  if (notableLayer) { map.removeLayer(notableLayer); notableLayer = null }

  perfEnd('map')

  if (fitToObservations && nextData.length > 0) {
    const lats = nextData.map((p) => p.lat)
    const lngs = nextData.map((p) => p.lng)
    const bounds = L.latLngBounds(
      [Math.min(...lats), Math.min(...lngs)],
      [Math.max(...lats), Math.max(...lngs)]
    )
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [24, 24], maxZoom: MAP_POINTS_FIT_MAX_ZOOM, animate: false })
    }
  }
}

async function loadCountyNotables(latitude, longitude, countyRegion = null, requestId = null, countySwitchRequestId = null, allowStateFallback = false) {
  perfStart('fetch')
  const notablesLoadId = ++latestNotablesLoadId
  const previousObservations = Array.isArray(currentRawObservations) ? currentRawObservations.slice() : []
  const previousCountyNameState = currentCountyName
  const previousCountyRegionState = currentCountyRegion
  const previousActiveCountyCodeState = currentActiveCountyCode
  const normalizedTargetRegion = String(countyRegion || '').toUpperCase() || null
  const normalizedPreviousRegion = String(previousCountyRegionState || '').toUpperCase() || null
  const isExplicitCountySwitch = countySwitchRequestId !== null && Boolean(normalizedTargetRegion) && normalizedTargetRegion !== normalizedPreviousRegion
  const previousCountText = notableCount.textContent
  const previousMetaText = notableMeta.textContent
  const previousRowsHtml = notableRows.innerHTML
  const previousRenderStatus = tableRenderStatus?.textContent || ''
  const hadPreviousRows = /<tr[\s>]/i.test(previousRowsHtml) && !/(Loading county notables|request timed out|did not complete|not available right now|No notable observations found)/i.test(previousRowsHtml)
  const cachedWarm = !hadPreviousRows ? loadNotablesCache(countyRegion) : null
  const hasCachedWarm = Array.isArray(cachedWarm?.observations) && cachedWarm.observations.length > 0

  setMapLoading(true, 'Loading notable observations…')
  setTableRenderStatus('load-start')
  if (hasCachedWarm) {
    currentRawObservations = cachedWarm.observations
    currentCountyName = cachedWarm?.countyName || null
    currentCountyRegion = cachedWarm?.countyRegion || countyRegion || null
    currentActiveCountyCode = (cachedWarm?.countyRegion || countyRegion || '').toUpperCase()
    rememberLastGoodObservations(currentRawObservations, currentCountyName, currentCountyRegion, currentActiveCountyCode)
    refreshCountyPickerSummaries()
    const warmFiltered = applyActiveFiltersAndRender({ renderMap: false })
    await new Promise((resolve) => window.setTimeout(resolve, 0))
    if (!isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) {
      setMapLoading(true, 'Rendering map points…')
      renderNotablesOnMap(warmFiltered, currentActiveCountyCode, true)
      maybeApplyHiResOnCountyLoad()
    }
    notableMeta.textContent = `${notableMeta.textContent} · cached`
    setTableRenderStatus(`cache-warm rows=${cachedWarm.observations.length}`)
    markMapPartReady('observations')
  } else {
    notableCount.className = 'badge warn'
    notableCount.textContent = hadPreviousRows ? 'Refreshing…' : 'Loading…'
    notableMeta.textContent = hadPreviousRows ? 'Refreshing county notables…' : 'Loading county notables…'
  }
  if (!hadPreviousRows && !hasCachedWarm) {
    updateStatPills('…', '…', '…')
    notableRows.innerHTML = '<tr><td colspan="7">Loading county notables…</td></tr>'
  }

  const loadingWatchdog = window.setTimeout(() => {
    if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) return
    if (notableCount.textContent !== 'Loading…' && notableCount.textContent !== 'Refreshing…') return
    if (hadPreviousRows) {
      if (!isExplicitCountySwitch) {
        notableCount.className = 'badge ok'
        notableCount.textContent = previousCountText
        notableMeta.textContent = `${previousMetaText} · refresh-timeout`
        notableRows.innerHTML = previousRowsHtml
        if (tableRenderStatus) {
          tableRenderStatus.textContent = previousRenderStatus || 'render: refresh-timeout-restored'
        }
        markMapPartReady('observations')
        return
      }
    }
    notableCount.className = 'badge warn'
    notableCount.textContent = '0'
    notableMeta.textContent = 'County notables request timed out'
    updateStatPills('0', '0', '0')
    notableRows.innerHTML = '<tr><td colspan="7">County notables request timed out. Try refresh or Use My Location again.</td></tr>'
    setTableRenderStatus('watchdog-timeout')
    markMapPartReady('observations')
  }, 9000)

  try {
    let result = null
    let observations = []
    let strategy = null

    // Fire primary (with countyRegion) and generic fallback concurrently so we
    // don't stack two sequential 5 s timeouts when the primary is slow/failing.
    const needFallback = !countyRegion // if no region provided, only one fetch needed
    const primaryPromise = fetchCountyNotablesWithRetry(latitude, longitude, 14, countyRegion, 1).catch((e) => { console.warn('Primary county notables failed:', e); return null })
    const fallbackPromise = needFallback
      ? primaryPromise
      : fetchCountyNotablesWithRetry(latitude, longitude, 14, null, 1).catch((e) => { console.warn('Fallback county notables failed:', e); return null })

    const [primaryResult, fallbackResult] = await Promise.all([primaryPromise, fallbackPromise])

    const primaryObs = Array.isArray(primaryResult?.observations) ? primaryResult.observations : []
    const fallbackObs = Array.isArray(fallbackResult?.observations) ? fallbackResult.observations : []

    if (countyRegion) {
      if (primaryResult && primaryObs.length > 0) {
        result = primaryResult
        observations = primaryObs
        strategy = primaryResult?.sourceStrategy || 'county-region'
      } else if (fallbackResult && fallbackObs.length > 0) {
        result = fallbackResult
        observations = fallbackObs
        strategy = fallbackResult?.sourceStrategy || 'county-fallback'
      } else if (primaryResult) {
        result = primaryResult
        observations = primaryObs
        strategy = primaryResult?.sourceStrategy || 'county-region'
      } else if (fallbackResult) {
        result = fallbackResult
        observations = fallbackObs
        strategy = fallbackResult?.sourceStrategy || 'county-fallback'
      }
    } else if (primaryObs.length >= fallbackObs.length && primaryObs.length > 0) {
      result = primaryResult
      observations = primaryObs
      strategy = primaryResult?.sourceStrategy || 'county-region'
    } else if (fallbackObs.length > 0) {
      result = fallbackResult
      observations = fallbackObs
      strategy = fallbackResult?.sourceStrategy || 'county-fallback'
    }

    if (allowStateFallback && !isExplicitCountySwitch && observations.length === 0 && countyRegion) {
      const stateRegion = stateRegionFromCountyRegion(countyRegion)
      if (stateRegion) {
        try {
            const stateData = await fetchRegionRarities(stateRegion, 14)
          const filtered = Array.isArray(stateData)
            ? stateData.filter((item) => String(item?.subnational2Code || '').toUpperCase() === countyRegion)
            : []

          if (filtered.length > observations.length) {
            observations = filtered
            strategy = 'state-filter-client'
            result = {
              countyName: null,
              countyRegion,
              sourceStrategy: strategy,
            }
          }
        } catch (stateFallbackError) {
          console.warn('State filtered fallback failed:', stateFallbackError)
        }
      }
    }

    if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) {
      return
    }

    if (observations.length > 0) {
      saveNotablesCache(result?.countyRegion || countyRegion || null, result)
    }

    const activeCountyCode = (result?.countyRegion || countyRegion || '').toUpperCase()
    const filteredObs = activeCountyCode
      ? observations.filter((item) => !item.subnational2Code || String(item.subnational2Code).toUpperCase() === activeCountyCode)
      : observations
    let displayObs = activeCountyCode ? filteredObs : observations
    if (allowStateFallback && !isExplicitCountySwitch && countyRegion && activeCountyCode && displayObs.length === 0) {
      const stateRegion = stateRegionFromCountyRegion(activeCountyCode)
      if (stateRegion) {
        try {
          const stateData = await fetchRegionRarities(stateRegion, 14)
          const stateFiltered = Array.isArray(stateData)
            ? stateData.filter((item) => String(item?.subnational2Code || '').toUpperCase() === activeCountyCode)
            : []
          if (stateFiltered.length > 0) {
            displayObs = stateFiltered
            strategy = 'state-filter-client'
          }
        } catch (stateFallbackError) {
          console.warn('State fallback after county filter-empty failed:', stateFallbackError)
        }
      }
    }
    if (displayObs.length === 0 && !isExplicitCountySwitch) {
      const recoveryTarget = activeCountyCode || countyRegion || previousCountyRegionState || null
      const recovery = getRecoverySnapshot(recoveryTarget)
      if (recovery && Array.isArray(recovery.observations) && recovery.observations.length > 0) {
        displayObs = recovery.observations.slice()
        strategy = `${strategy || 'county-region'}-recovered`
        currentCountyName = recovery.countyName || currentCountyName || null
        currentCountyRegion = recovery.countyRegion || countyRegion || currentCountyRegion || null
        currentActiveCountyCode = String(recovery.activeCountyCode || currentActiveCountyCode || '').toUpperCase()
      }
    }

    const resolvedCountyName = result?.countyName || currentCountyName || previousCountyNameState || null
    const resolvedCountyRegion = result?.countyRegion || currentCountyRegion || countyRegion || previousCountyRegionState || null
    const resolvedActiveCountyCode = String(activeCountyCode || currentActiveCountyCode || resolvedCountyRegion || previousActiveCountyCodeState || '').toUpperCase()

    currentRawObservations = displayObs
    currentCountyName = resolvedCountyName
    currentCountyRegion = resolvedCountyRegion
    currentActiveCountyCode = resolvedActiveCountyCode
    if (displayObs.length > 0) {
      rememberLastGoodObservations(displayObs, currentCountyName, currentCountyRegion, currentActiveCountyCode)
    } else if (previousObservations.length > 0 && !isExplicitCountySwitch) {
      currentRawObservations = previousObservations
      currentCountyName = previousCountyNameState
      currentCountyRegion = previousCountyRegionState
      currentActiveCountyCode = previousActiveCountyCodeState
      strategy = `${strategy || 'county-region'}-restored`
    }

    // Prefer a stable county-center anchor (from picker options) over the
    // triggering lat/lng (which may be user's GPS inside the county).
    const anchorRegion = String(currentActiveCountyCode || currentCountyRegion || '').toUpperCase()
    const anchorOption = countyPickerOptions.find((opt) => String(opt?.countyRegion || '').toUpperCase() === anchorRegion) || null
    const anchorLat = Number(anchorOption?.lat)
    const anchorLng = Number(anchorOption?.lng)
    if (Number.isFinite(anchorLat) && Number.isFinite(anchorLng)) {
      setCountyDistanceAnchor(anchorLat, anchorLng, anchorRegion)
    } else {
      setCountyDistanceAnchor(latitude, longitude, anchorRegion)
    }

    // Keep county picker sorted around the active county (state list), if available.
    const stateRegion = stateRegionFromCountyRegion(currentActiveCountyCode || currentCountyRegion || '')
    const cachedStateEntries = stateRegion ? stateCountyOptionsCache.get(stateRegion) : null
    if (stateRegion && Array.isArray(cachedStateEntries) && cachedStateEntries.length > 1) {
      applyCountyPickerOptionsFromStateEntries(
        cachedStateEntries,
        currentActiveCountyCode || '',
        (Number.isFinite(lastCountyAnchorLat) && Number.isFinite(lastCountyAnchorLng))
          ? { lat: lastCountyAnchorLat, lng: lastCountyAnchorLng }
          : null
      )
    }
    refreshCountyPickerSummaries()
    const displayFiltered = applyActiveFiltersAndRender({ renderMap: false })
    perfEnd('fetch')
    perfStart('table')
    setTableRenderStatus(`table-ok rows=${currentRawObservations.length}`)
    perfEnd('table')
    await new Promise((resolve) => window.setTimeout(resolve, 0))
    if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) return
    setMapLoading(true, 'Rendering map points…')
    renderNotablesOnMap(displayFiltered, currentActiveCountyCode, true)
    setTableRenderStatus(`map-ok points=${displayFiltered.length}`)
    maybeApplyHiResOnCountyLoad()
    if (strategy) {
      notableMeta.textContent = `${notableMeta.textContent} · ${strategy}`
    }
    updateRuntimeLog()
  } catch (error) {
    console.error('County notables unavailable:', error)
    if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) {
      return
    }

    if (hadPreviousRows) {
      if (!isExplicitCountySwitch) {
        notableCount.className = 'badge ok'
        notableCount.textContent = previousCountText
        notableMeta.textContent = `${previousMetaText} · refresh-failed`
        notableRows.innerHTML = previousRowsHtml
        if (tableRenderStatus) {
          tableRenderStatus.textContent = previousRenderStatus || 'render: refresh-failed-restored'
        }
        return
      }
    }

    const cached = loadNotablesCache(countyRegion)
    if (cached && Array.isArray(cached.observations) && cached.observations.length > 0) {
      currentRawObservations = cached.observations
      currentCountyName = cached?.countyName || null
      currentCountyRegion = cached?.countyRegion || countyRegion || null
      currentActiveCountyCode = (cached?.countyRegion || countyRegion || '').toUpperCase()
      rememberLastGoodObservations(currentRawObservations, currentCountyName, currentCountyRegion, currentActiveCountyCode)
      refreshCountyPickerSummaries()
      const cachedFiltered = applyActiveFiltersAndRender({ renderMap: false })
      await new Promise((resolve) => window.setTimeout(resolve, 0))
      if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) return
      setMapLoading(true, 'Rendering map points…')
      renderNotablesOnMap(cachedFiltered, currentActiveCountyCode, true)
      maybeApplyHiResOnCountyLoad()
      notableMeta.textContent = `${notableMeta.textContent} · cached-fallback`
      setTableRenderStatus(`cache-ok rows=${cached.observations.length}`)
      return
    }

    const recovery = getRecoverySnapshot(countyRegion || previousCountyRegionState || null)
    if (recovery && Array.isArray(recovery.observations) && recovery.observations.length > 0) {
      currentRawObservations = recovery.observations.slice()
      currentCountyName = recovery.countyName || previousCountyNameState || null
      currentCountyRegion = recovery.countyRegion || countyRegion || previousCountyRegionState || null
      currentActiveCountyCode = String(recovery.activeCountyCode || previousActiveCountyCodeState || '').toUpperCase()
      refreshCountyPickerSummaries()
      const recoveredFiltered = applyActiveFiltersAndRender({ renderMap: false })
      await new Promise((resolve) => window.setTimeout(resolve, 0))
      if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) return
      setMapLoading(true, 'Rendering map points…')
      renderNotablesOnMap(recoveredFiltered, currentActiveCountyCode, true)
      maybeApplyHiResOnCountyLoad()
      notableMeta.textContent = `${notableMeta.textContent} · recovered`
      setTableRenderStatus(`recover-ok rows=${recovery.observations.length}`)
      return
    }

    notableCount.className = 'badge warn'
    notableCount.textContent = '0'
    notableMeta.textContent = 'County notables currently unavailable'
    updateStatPills('0', '0', '0')
    notableRows.innerHTML = '<tr><td colspan="7">No notable observations available right now.</td></tr>'
    setTableRenderStatus(`load-error err=${error?.message || 'unknown'}`)
    updateRuntimeLog()
  } finally {
    window.clearTimeout(loadingWatchdog)
    if (isStaleNotablesLoad(notablesLoadId, requestId, countySwitchRequestId)) {
      return
    }
    if (notableCount.textContent === 'Loading…' || notableCount.textContent === 'Refreshing…') {
      if (hadPreviousRows) {
        notableCount.className = 'badge ok'
        notableCount.textContent = previousCountText
        notableMeta.textContent = `${previousMetaText} · refresh-incomplete`
        notableRows.innerHTML = previousRowsHtml
        if (tableRenderStatus) {
          tableRenderStatus.textContent = previousRenderStatus || 'render: refresh-incomplete-restored'
        }
        markMapPartReady('observations')
        return
      }
      notableCount.className = 'badge warn'
      notableCount.textContent = '0'
      updateStatPills('0', '0', '0')
      notableMeta.textContent = 'County notables request did not complete'
      notableRows.innerHTML = '<tr><td colspan="7">County notables request did not complete. Please try again.</td></tr>'
      setTableRenderStatus('load-finalized-no-data')
    }
    markMapPartReady('observations')
    updateRuntimeLog()
  }
}

async function updateCountyForLocation(latitude, longitude, requestId = null, countySwitchRequestId = null) {
  try {
    setMapLoading(true, 'Loading county…')
    const geojson = await fetchCountyContextWithCache(latitude, longitude)
    if ((requestId !== null && isStaleLocationRequest(requestId)) || (countySwitchRequestId !== null && isStaleCountySwitchRequest(countySwitchRequestId))) {
      return { countyLabel: null, countyRegion: null }
    }
    drawCountyOverlay(geojson)
    const countyFeature = Array.isArray(geojson?.features)
      ? geojson.features.find((f) => f?.properties?.isActiveCounty)
      : null
    const countyLabel = countyFeature?.properties?.countyName || countyFeature?.properties?.NAME || countyFeature?.properties?.name || null
    const countyRegion = countyFeature?.properties?.countyRegion || geojson?.activeCountyRegion || null
    return { countyLabel, countyRegion }
  } catch (error) {
    console.error('County context unavailable:', error)
    setMapLoading(false)
    return { countyLabel: null, countyRegion: null }
  }
}

async function loadStateNotables(stateRegion, requestId = null) {
  const notablesLoadId = ++latestNotablesLoadId
  const normalizedState = String(stateRegion || '').toUpperCase()
  setMapLoading(true, `Loading ${stateRegion} notables…`)
  setTableRenderStatus('load-start')
  notableCount.className = 'badge warn'
  notableCount.textContent = 'Loading…'
  notableMeta.textContent = `Loading rarities for ${stateRegion}…`
  updateStatPills('…', '…', '…')
  notableRows.innerHTML = '<tr><td colspan="7">Loading notables…</td></tr>'

  try {
    const effectiveDaysBack = Math.max(1, Math.min(14, Number(filterDaysBack) || 7))
    const observations = await fetchRegionRarities(stateRegion, effectiveDaysBack, 45000)
    if (isStaleNotablesLoad(notablesLoadId, requestId)) return
    let stateCountyGeojson = null
    try {
      stateCountyGeojson = await fetchStateCountyGeometry(normalizedState)
      if (!isStaleNotablesLoad(notablesLoadId, requestId)) {
        const stateMaskGeojson = buildStateMaskGeojson(normalizedState, stateCountyGeojson)
        if (stateMaskGeojson) drawCountyOverlay(stateMaskGeojson)
        zoomToStateBounds(stateCountyGeojson, normalizedState)
      }
    } catch (overlayError) {
      console.warn('State mask overlay unavailable:', overlayError)
      markMapPartReady('activeCounty')
      markMapPartReady('stateMask')
    }
    currentRawObservations = Array.isArray(observations) ? observations : []
    saveNotablesCache(normalizedState, { observations: currentRawObservations })
    const stateCountyEntries = buildStateCountyEntries(currentRawObservations, stateRegion)
    stateCountyOptionsCache.set(stateRegion, stateCountyEntries)
    currentCountyName = getStateNameByRegion(normalizedState)
    currentCountyRegion = normalizedState
    currentActiveCountyCode = ''
    refreshHeaderStateOptions()
    renderStatePickerOptions()
    applyCountyPickerOptionsFromStateEntries(
      stateCountyEntries,
      '',
      (Number.isFinite(lastCountyAnchorLat) && Number.isFinite(lastCountyAnchorLng))
        ? { lat: lastCountyAnchorLat, lng: lastCountyAnchorLng }
        : (Number.isFinite(lastUserLat) && Number.isFinite(lastUserLng) ? { lat: lastUserLat, lng: lastUserLng } : null)
    )
    refreshSearchCountyOptions(currentRawObservations, stateRegion)
    refreshHeaderCountyOptions()
    rememberLastGoodObservations(currentRawObservations, currentCountyName, normalizedState, '')
    applyActiveFiltersAndRender({ renderMap: true, fitToObservations: true })
    setMapLoading(false)
    markMapPartReady('observations')
  } catch (error) {
    if (isStaleNotablesLoad(notablesLoadId, requestId)) return
    console.error('loadStateNotables error:', error)
    notableCount.className = 'badge warn'
    notableCount.textContent = '0'
    notableMeta.textContent = `Error: ${error?.message || error}`
    updateStatPills('0', '0', '0')
    const safeErrorMessage = escapeHtml(error?.message || 'unknown error')
    notableRows.innerHTML = `<tr><td colspan="7">Load failed: ${safeErrorMessage}.</td></tr>`
    setTableRenderStatus(`state-error: ${error?.message || ''}`)
    setMapLoading(false)
    markMapPartReady('observations')
  }
}

async function loadNationalNotables(regionCode = US_REGION_CODE, abaMinFloor = 3, requestId = null) {
  const notablesLoadId = ++latestNotablesLoadId
  const normalizedRegion = String(regionCode || '').toUpperCase() || US_REGION_CODE
  const effectiveAbaMin = Math.max(3, Number(abaMinFloor) || 3)

  setMapLoading(true, `Loading ${normalizedRegion} notables…`)
  setTableRenderStatus('us-load-start')
  notableCount.className = 'badge warn'
  notableCount.textContent = 'Loading…'
  notableMeta.textContent = `Loading rarities for ${normalizedRegion} (ABA ${effectiveAbaMin}+)…`
  updateStatPills('…', '…', '…')
  notableRows.innerHTML = '<tr><td colspan="7">Loading US notables…</td></tr>'

  try {
    const observations = await fetchRegionRarities(normalizedRegion, filterDaysBack, 45000, { abaMin: effectiveAbaMin })
    if (isStaleNotablesLoad(notablesLoadId, requestId)) return

    currentRawObservations = Array.isArray(observations) ? observations : []
    currentCountyName = 'United States'
    currentCountyRegion = US_REGION_CODE
    currentActiveCountyCode = ''
    countyPickerOptions = []
    refreshHeaderStateOptions()
    renderStatePickerOptions()
    refreshHeaderCountyOptions()
    setSearchCountyIdleMessage('County select disabled for US')
    rememberLastGoodObservations(currentRawObservations, currentCountyName, currentCountyRegion, '')

    if (neighborLayerRef) neighborLayerRef.clearLayers()
    if (countyOverlay) countyOverlay.clearLayers()
    if (activeOutlineLayerRef) activeOutlineLayerRef.clearLayers()
    if (countyNameLayerRef) countyNameLayerRef.clearLayers()
    if (countyDotLayerRef) countyDotLayerRef.clearLayers()

    markMapPartReady('activeCounty')
    markMapPartReady('stateMask')

    if (map) {
      map.fitBounds(L.latLngBounds([24.5, -125], [49.5, -66.5]), { padding: [20, 20], maxZoom: 5, animate: true })
    }

    applyActiveFiltersAndRender({ renderMap: true, fitToObservations: false })
    setMapLoading(false)
    markMapPartReady('observations')
  } catch (error) {
    if (isStaleNotablesLoad(notablesLoadId, requestId)) return
    console.error('loadNationalNotables error:', error)
    notableCount.className = 'badge warn'
    notableCount.textContent = '0'
    notableMeta.textContent = `Error: ${error?.message || error}`
    updateStatPills('0', '0', '0')
    const safeErrorMessage = escapeHtml(error?.message || 'unknown error')
    notableRows.innerHTML = `<tr><td colspan="7">US load failed: ${safeErrorMessage}.</td></tr>`
    setTableRenderStatus(`us-error: ${error?.message || ''}`)
    setMapLoading(false)
    markMapPartReady('observations')
  }
}

async function loadNeighborCounty(lat, lng, countyRegion, countyName) {
  const normalizedCountyRegion = countyRegion ? String(countyRegion).toUpperCase() : null
  // Avoid Number(null) => 0 (which would incorrectly send us to 0,0).
  let targetLat = (lat === null || lat === undefined || lat === '') ? NaN : Number(lat)
  let targetLng = (lng === null || lng === undefined || lng === '') ? NaN : Number(lng)
  const countySwitchRequestId = ++latestCountySwitchRequestId
  mapLoadState.activeCounty = false
  mapLoadState.stateMask = false
  mapLoadState.observations = false
  setMapLoading(true, 'Switching county…')

  try {
    let countyContextPromise
    let zoomGeojson = null
    const localCountyGeojson = buildCountyGeojsonWithActiveRegion(latestCountyContextGeojson, normalizedCountyRegion || null)
    if (localCountyGeojson) {
      const localCountyFeature = localCountyGeojson.features.find((f) => f?.properties?.isActiveCounty)
      const localCountyRegion = String(localCountyFeature?.properties?.countyRegion || normalizedCountyRegion || '').toUpperCase() || null
      if (localCountyRegion) {
        currentCountyRegion = localCountyRegion
        currentActiveCountyCode = localCountyRegion
      }
      drawCountyOverlay(localCountyGeojson)
      zoomGeojson = localCountyGeojson
      const localCountyLabel = localCountyFeature?.properties?.countyName || localCountyFeature?.properties?.NAME || localCountyFeature?.properties?.name || countyName || null
      const center = getFeatureCenter(localCountyFeature)
      if ((!Number.isFinite(targetLat) || !Number.isFinite(targetLng)) && center) {
        targetLat = center.lat
        targetLng = center.lng
      }
      countyContextPromise = Promise.resolve({ countyLabel: localCountyLabel, countyRegion: localCountyRegion })
    } else {
      if (!Number.isFinite(targetLat) || !Number.isFinite(targetLng)) {
        if (Number.isFinite(lastUserLat) && Number.isFinite(lastUserLng)) {
          targetLat = lastUserLat
          targetLng = lastUserLng
        } else if (map) {
          const center = map.getCenter()
          targetLat = center.lat
          targetLng = center.lng
        }
      }
      countyContextPromise = updateCountyForLocation(targetLat, targetLng, null, countySwitchRequestId)
    }
    const countyContext = await countyContextPromise

    if (isStaleCountySwitchRequest(countySwitchRequestId)) return

    const resolvedCountyRegion = String(countyContext?.countyRegion || normalizedCountyRegion || '').toUpperCase() || null

    if (resolvedCountyRegion && Number.isFinite(targetLat) && Number.isFinite(targetLng)) {
      setCountyDistanceAnchor(targetLat, targetLng, resolvedCountyRegion)
    }

    if (!zoomGeojson && latestCountyContextGeojson) zoomGeojson = latestCountyContextGeojson
    const zoomed = zoomToActiveCounty(zoomGeojson, resolvedCountyRegion)
    if (!zoomed && map && Number.isFinite(targetLat) && Number.isFinite(targetLng)) {
      map.setView([targetLat, targetLng], Math.max(map.getZoom(), 9), { animate: true })
    }

    const label = countyContext?.countyLabel || countyName || ''
    await loadCountyNotables(targetLat, targetLng, resolvedCountyRegion, null, countySwitchRequestId, true)
  } catch (error) {
    console.error('loadNeighborCounty failed:', error)
    if (!isStaleCountySwitchRequest(countySwitchRequestId)) {
      setMapLoading(false)
      restoreFromRecoverySnapshot('county-switch-error')
      updateRuntimeLog()
    }
  }
}

async function requestUserLocation(manualRetry = false) {
  perfStart('location')
  const requestId = ++latestLocationRequestId

  const isSecureOrigin = window.isSecureContext

  if (!('geolocation' in navigator)) {
    setLocationUiUnavailable('Location is not supported on this device/browser.')
    setNotablesUnavailableState(
      'County notables unavailable without location',
      'Location is not supported on this device/browser.',
      'location-unsupported'
    )
    return false
  }

  const permissionState = await getGeolocationPermissionState()
  if (permissionState === 'denied') {
    setLocationUiBlocked()
    setNotablesUnavailableState(
      'County notables unavailable until location is allowed',
      'Location permission is blocked. Allow location and tap Use My Location again.',
      'location-denied'
    )
    return false
  }

  setLocationUiChecking()
  if (!isSecureOrigin) {
    locationStatus.className = 'badge warn'
    locationStatus.textContent = 'Checking...'
    locationDetail.textContent = 'Non-secure origin detected. Attempting location; if blocked, open over HTTPS or localhost.'
  }
  resetMapLoadState()

  try {
    let position
    try {
      position = await getCurrentPositionAsync({
        enableHighAccuracy: true,
        timeout: 12000,
        maximumAge: 60000
      })
    } catch (highAccuracyError) {
      const retryable = highAccuracyError && (highAccuracyError.code === 2 || highAccuracyError.code === 3)
      if (!retryable) {
        throw highAccuracyError
      }

      locationDetail.textContent = 'High-accuracy attempt failed; retrying with standard accuracy.'
      position = await getCurrentPositionAsync({
        enableHighAccuracy: false,
        timeout: 20000,
        maximumAge: 30000
      })
    }

    const { latitude, longitude, accuracy } = position.coords
    lastUserLat = latitude
    lastUserLng = longitude
    // Persist so next app open can skip the browser prompt
    try { localStorage.setItem('mrm_last_pos', JSON.stringify({ lat: latitude, lng: longitude, ts: Date.now() })) } catch (_) {}
    if (isStaleLocationRequest(requestId)) {
      return false
    }

    locationStatus.className = 'badge ok'
    locationStatus.textContent = 'Located'
    const baseLocationDetail = `Lat ${latitude.toFixed(5)}, Lon ${longitude.toFixed(5)} · ±${Math.round(accuracy)} m`
    locationDetail.textContent = baseLocationDetail
    perfEnd('location')
    updateUserLocationOnMap(latitude, longitude, accuracy)

    // Extract cached county region so notables fetch can skip its own TIGER lookup
    const cachedGeoJson = loadCountyContextCache(latitude, longitude)
    const cachedActiveFeature = Array.isArray(cachedGeoJson?.features)
      ? cachedGeoJson.features.find((f) => f?.properties?.isActiveCounty)
      : null
    const cachedCountyRegion = cachedActiveFeature?.properties?.countyRegion || cachedGeoJson?.activeCountyRegion || null

    // Fire county outline and notables in parallel; pass cached region to notables so it skips its own TIGER call.
    perfStart('county')
    const countyContextPromise = updateCountyForLocation(latitude, longitude, requestId)
    const notablesPromise = loadCountyNotables(latitude, longitude, cachedCountyRegion, requestId, null, manualRetry)
    const countyContext = await countyContextPromise
    perfEnd('county')

    if (isStaleLocationRequest(requestId)) {
      return false
    }

    if (countyContext?.countyLabel) {
      const regionHint = countyContext?.countyRegion ? ` (${countyContext.countyRegion})` : ''
      locationDetail.textContent = `${baseLocationDetail} · ${countyContext.countyLabel}${regionHint}`
    }
    await notablesPromise
    updateRuntimeLog()
    return true
  } catch (error) {
    let reason = error && error.message ? error.message : 'Location permission was denied or timed out.'

    if (error && typeof error.code === 'number') {
      if (error.code === 1) {
        reason = !isSecureOrigin
          ? 'Location blocked on non-secure origin. Open over HTTPS (or localhost) and try again.'
          : 'Permission denied. On iOS Safari, allow Location for Safari (or Home Screen app) and keep Precise Location enabled.'
      } else if (error.code === 2) {
        reason = 'Position unavailable. Move to an open area and verify Location Services are on.'
      } else if (error.code === 3) {
        reason = 'Location request timed out. Try again while outdoors or on stronger signal.'
      }
    }

    setLocationUiUnavailable(reason)
    setNotablesUnavailableState(
      'County notables unavailable due to location error',
      reason,
      'location-error'
    )
    setMapLoading(false)
    console.error(error)
    updateRuntimeLog()
    return false
  }
}

retryLocationBtn.addEventListener('click', () => { void requestUserLocation(true) })
menuInfoBtn?.addEventListener('click', () => {
  if (!infoModal) return
  renderInfoTechMetrics()
  renderTapDebugLog()
  infoModal.removeAttribute('hidden')
})
infoCloseBtn?.addEventListener('click', () => {
  infoModal?.setAttribute('hidden', 'hidden')
})
headerDaysBackSelect?.addEventListener('change', (event) => {
  filterDaysBack = Number(event.target.value) || 7
  if (filterDaysBackInput) filterDaysBackInput.value = String(filterDaysBack)
  updateFilterUi()
  applyActiveFiltersAndRender({ fitToObservations: true })
})

headerCountyBtn?.addEventListener('click', (event) => {
  event.preventDefault()
  toggleCountyPicker()
})

headerStateBtn?.addEventListener('click', (event) => {
  event.preventDefault()
  renderStatePickerOptions()
  toggleStatePicker()
})

headerStateSelect?.addEventListener('change', async (event) => {
  const next = String(event?.target?.value || '').toUpperCase()
  if (!/^US-[A-Z]{2}$/.test(next)) return
  await activateStateByRegion(next)
})

headerCountySelect?.addEventListener('change', (event) => {
  const selectEl = event.target
  const countyRegion = String(selectEl?.value || '').toUpperCase()
  if (!countyRegion) return
  const option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === countyRegion) || null
  if (option) {
    activateCountyFromOption(option)
    return
  }

  // Fallback: activate by region with unknown center (loadNeighborCounty will resolve from cached/geojson if possible)
  activateCountyByRegion(countyRegion, null, null, '')
})
filterDaysBackInput?.addEventListener('input', (event) => {
  filterDaysBack = Number(event.target.value) || 7
  updateFilterUi()
  applyActiveFiltersAndRender({ fitToObservations: true })
})
filterAbaMinInput?.addEventListener('input', (event) => {
  filterAbaMin = Number(event.target.value) || 1
  updateFilterUi()
  applyActiveFiltersAndRender()
})
updateFilterUi()
menuSearchBtn?.addEventListener('click', () => {
  if (!searchPopover) return
  refreshSearchRegionOptions()
  void ensureSearchCountyOptionsForState(searchRegionSelect?.value || stateRegionFromCountyRegion(currentCountyRegion || '') || '')
  updateFilterUi()
  syncSearchSlidersForRegion(searchRegionSelect?.value || stateRegionFromCountyRegion(currentCountyRegion || '') || '')
  searchPopover.toggleAttribute('hidden')
})
searchRegionSelect?.addEventListener('change', () => {
  const newRegion = searchRegionSelect?.value || ''
  if (currentCountyRegion === US_REGION_CODE && newRegion !== US_REGION_CODE) {
    if (searchAbaMinInput) searchAbaMinInput.value = '1'
  }
  syncSearchSlidersForRegion(newRegion)
  setSearchCountyLoading('Loading counties…')
  void ensureSearchCountyOptionsForState(newRegion)
})
searchDaysBackInput?.addEventListener('input', () => {
  if (!searchDaysBackValue || !searchDaysBackInput) return
  searchDaysBackValue.textContent = String(Math.max(1, Math.min(14, Number(searchDaysBackInput.value) || filterDaysBack)))
})
searchAbaMinInput?.addEventListener('input', () => {
  syncSearchSlidersForRegion(searchRegionSelect?.value || stateRegionFromCountyRegion(currentCountyRegion || '') || '')
})
searchCloseBtn?.addEventListener('click', () => {
  searchPopover?.setAttribute('hidden', 'hidden')
})
searchApplyBtn?.addEventListener('click', async () => {
  if (searchApplyInProgress) return
  searchApplyInProgress = true
  const selectedRegion = String(searchRegionSelect?.value || '').toUpperCase()
  const selectedCountyRegion = String(searchCountySelect?.value || '').toUpperCase()
  const selectedName = searchSpeciesSelect ? String(searchSpeciesSelect.value || '').trim() : ''
  const chosenDays = Number(searchDaysBackInput?.value || filterDaysBack) || filterDaysBack
  const requestedAbaMin = Number(searchAbaMinInput?.value || filterAbaMin) || filterAbaMin
  const effectiveAbaMin = getEffectiveSearchAbaMin(selectedRegion, requestedAbaMin)
  try {
    // Species search field is currently removed from the UI; don't clobber any active species filter.
    if (searchSpeciesSelect) selectedSpecies = selectedName || null
    filterDaysBack = chosenDays
    filterAbaMin = effectiveAbaMin
    if (filterDaysBackInput) filterDaysBackInput.value = String(filterDaysBack)
    if (filterAbaMinInput) filterAbaMinInput.value = String(filterAbaMin)
    updateFilterUi()
    syncSearchSlidersForRegion(selectedRegion)
    applyActiveFiltersAndRender({ fitToObservations: true })
    // Selection priority (wireframe contract): county > state/US.
    if (/^US-[A-Z]{2}-\d{3}$/.test(selectedCountyRegion)) {
      activateCountyFromSearchSelection(selectedCountyRegion)
    } else if (selectedRegion) {
      if (selectedRegion === US_REGION_CODE) {
        await loadNationalNotables(selectedRegion, effectiveAbaMin)
      } else if (/^US-[A-Z]{2}$/.test(selectedRegion)) {
        await loadStateNotables(selectedRegion)
      }
    }
    searchPopover?.setAttribute('hidden', 'hidden')
  } catch (error) {
    console.error('search apply failed:', error)
    setMapLoading(false)
    restoreFromRecoverySnapshot('search-apply-error')
    updateRuntimeLog()
  } finally {
    searchApplyInProgress = false
  }
})

tapDebugEnabled = loadTapDebugEnabled()
if (tapDebugToggle) {
  tapDebugToggle.checked = tapDebugEnabled
  tapDebugToggle.addEventListener('change', (event) => {
    tapDebugEnabled = Boolean(event?.target?.checked)
    saveTapDebugEnabled(tapDebugEnabled)
    if (tapDebugEnabled) {
      logTapResolution('debug-enabled', { source: 'about-modal', detail: 'tap debugging turned on' })
    } else {
      renderTapDebugLog()
    }
  })
}
renderTapDebugLog()

function focusMapOnUserLocation() {
  if (!map) return
  if (lastUserLat !== null && lastUserLng !== null) {
    map.invalidateSize()
    map.setView([lastUserLat, lastUserLng], 14, { animate: true })
  } else {
    void requestUserLocation()
  }
}

menuPinBtn?.addEventListener('click', () => {
  focusMapOnUserLocation()
})
menuRefreshBtn?.addEventListener('click', () => {
  void triggerHardRefresh()
})

bottomReloadBtn?.addEventListener('click', () => {
  void triggerHardRefresh()
})
mapFullscreenToggleBtn.addEventListener('click', () => {
  setMapFullscreen(!isMapFullscreen)
})

mapBasemapToggleBtn?.addEventListener('click', () => {
  if (!map || !osmLayer || !satelliteLayer) return
  if (currentBasemap === 'osm') {
    map.removeLayer(osmLayer)
    satelliteLayer.addTo(map)
    currentBasemap = 'satellite'
    mapBasemapToggleBtn.title = 'Switch to Street map'
  } else {
    map.removeLayer(satelliteLayer)
    osmLayer.addTo(map)
    currentBasemap = 'osm'
    mapBasemapToggleBtn.title = 'Switch to Satellite'
  }
  updateBasemapAuxLayers()
  updateCountyLineColors()
})

mapLocateBtn?.addEventListener('click', () => {
  focusMapOnUserLocation()
})

mapLabelToggleBtn?.addEventListener('click', () => {
  if (labelMode === 'abbr') labelMode = 'full'
  else if (labelMode === 'full') labelMode = 'off'
  else labelMode = 'abbr'

  const mapEl = document.querySelector('#map')
  if (mapEl) mapEl.classList.toggle('labels-hidden', labelMode === 'off')
  mapLabelToggleBtn.setAttribute('aria-pressed', String(labelMode !== 'off'))
  mapLabelToggleBtn.style.opacity = labelMode === 'off' ? '0.5' : ''
  mapLabelToggleBtn.title = labelMode === 'abbr' ? 'Show full names' : labelMode === 'full' ? 'Hide labels' : 'Show abbreviated names'
  
  const textEl = mapLabelToggleBtn.querySelector('text')
  if (textEl) {
    textEl.textContent = labelMode === 'abbr' ? 'B' : labelMode === 'full' ? 'F' : ''
  }

  // Re-render canvas so label visibility takes effect immediately
  lastMapRenderSignature = ''
  applyActiveFiltersAndRender()
})

countyPickerList?.addEventListener('click', (event) => {
  const btn = event.target.closest('.county-option')
  if (!btn) return
  const index = Number(btn.dataset.index)
  const option = countyPickerOptions[index]
  if (!option) return
  closeCountyPicker()
  activateCountyFromOption(option)
})

statePickerList?.addEventListener('click', async (event) => {
  const btn = event.target.closest('.county-option')
  if (!btn) return
  const index = Number(btn.dataset.index)
  const state = LOWER_48_STATES[index]
  if (!state?.code) return
  closeStatePicker()
  await activateStateByRegion(state.code)
})

function activateAbaPill(pill) {
  if (!pill) return
  const parsedCode = Number(pill.dataset.code)
  if (!Number.isFinite(parsedCode)) return
  const code = Math.round(parsedCode)
  if (code < 1 || code > 6) return
  if (!(selectedAbaCodes instanceof Set)) selectedAbaCodes = new Set()
  if (selectedAbaCodes.has(code)) selectedAbaCodes.delete(code)
  else selectedAbaCodes.add(code)
  applyActiveFiltersAndRender({ allowAutoRecovery: false })
}

function bindAbaPillContainer(container) {
  if (!container) return
  container.addEventListener('click', (e) => {
    const pill = e.target.closest('.stat-aba-pill')
    activateAbaPill(pill)
  })
  container.addEventListener('keydown', (e) => {
    const pill = e.target.closest('.stat-aba-pill')
    if (!pill) return
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      activateAbaPill(pill)
    }
  })
}

bindAbaPillContainer(topAbaPills)
bindAbaPillContainer(pickerAbaPills)
bindAbaPillContainer(statePickerAbaPills)

abaCodePickerList?.addEventListener('click', (event) => {
  const btn = event.target.closest('.county-option')
  if (!btn) return
  const index = Number(btn.dataset.index)
  const option = abaCodePickerOptions[index]
  if (!option) return
  if (!(selectedAbaCodes instanceof Set)) selectedAbaCodes = new Set()
  if (option.value === 'all') {
    selectedAbaCodes = new Set()
  } else {
    const parsedCode = Number(option.value)
    if (Number.isFinite(parsedCode)) {
      const code = Math.round(parsedCode)
      if (selectedAbaCodes.has(code)) selectedAbaCodes.delete(code)
      else selectedAbaCodes.add(code)
    }
  }
  applyActiveFiltersAndRender({ allowAutoRecovery: false })
})

document.addEventListener('click', (event) => {
  const target = event.target
  if (!(target instanceof Node)) return
  if (searchPopover && !searchPopover.hasAttribute('hidden') && !searchPopover.contains(target) && !menuSearchBtn.contains(target)) {
    searchPopover.setAttribute('hidden', 'hidden')
  }
  if (countyPicker && !countyPicker.contains(target) && !(headerCountyBtn && headerCountyBtn.contains(target))) {
    closeCountyPicker()
  }
  if (statePicker && !statePicker.contains(target) && !(headerStateBtn && headerStateBtn.contains(target))) {
    closeStatePicker()
  }
  if (abaCodePicker && !abaCodePicker.contains(target) && !(topAbaPills && topAbaPills.contains(target))) {
    closeAbaCodePicker()
  }
  if (infoModal && !infoModal.hasAttribute('hidden')) {
    const shouldClose = target instanceof Element && target.getAttribute('data-close') === 'info'
    if (shouldClose) infoModal.setAttribute('hidden', 'hidden')
  }
})

notableRows.addEventListener('click', (event) => {
  const pinBtn = event.target.closest('.row-pin-btn')
  if (pinBtn) {
    const lat = pinBtn.dataset.lat
    const lng = pinBtn.dataset.lng
    if (lat && lng) {
      window.open(
        `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(`${lat},${lng}`)}`,
        '_blank', 'noopener'
      )
    }
    return
  }

  const countySummaryBtn = event.target.closest('.county-summary-btn')
  if (countySummaryBtn) {
    const row = countySummaryBtn.closest('tr')
    const rowCountyRegion = String(row?.dataset?.countyRegion || countySummaryBtn.dataset.countyRegion || '').toUpperCase()
    const rowCountyName = String(row?.dataset?.county || countySummaryBtn.textContent || '').trim()
    if (rowCountyRegion) {
      if (/^US-[A-Z]{2}$/.test(rowCountyRegion)) {
        // It's a state, load state notables and sync state/county pills.
        if (searchRegionSelect) searchRegionSelect.value = rowCountyRegion
        if (searchAbaMinInput) searchAbaMinInput.value = '1'
        syncSearchSlidersForRegion(rowCountyRegion)
        filterAbaMin = 1
        updateFilterUi()
        void activateStateByRegion(rowCountyRegion)
      } else {
        const option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === rowCountyRegion)
        if (option) {
          activateCountyFromOption(option)
        } else {
          activateCountyByRegion(rowCountyRegion, null, null, rowCountyName)
        }
      }
    }
    return
  }

  const btn = event.target.closest('.species-btn')
  if (!btn) return
  const species = btn.dataset.species
  if (!species) return

  // Pin this species to the top of the table.
  const wasPinned = pinnedSpecies === species
  pinnedSpecies = wasPinned ? null : species
  const pinnedNow = pinnedSpecies === species

  const row = btn.closest('tr')
  const rowCountyRegion = String(row?.dataset?.countyRegion || '').toUpperCase()
  const rowCountyName = String(row?.dataset?.county || '')
  const activeRegion = String(currentCountyRegion || '').toUpperCase()
  const isStateView = /^US-[A-Z]{2}$/.test(activeRegion)

  if (isStateView && rowCountyRegion) {
    preservePinnedSpeciesOnce = true
    selectedSpecies = species
    const option = countyPickerOptions.find((opt) => String(opt.countyRegion || '').toUpperCase() === rowCountyRegion)
    if (option) {
      activateCountyFromOption(option)
      return
    }
    activateCountyByRegion(rowCountyRegion, null, null, rowCountyName)
    return
  }

  applySortAndRender()
  const tableWrap = document.querySelector('.table-wrap')
  if (pinnedNow && tableWrap) tableWrap.scrollTop = 0

  // Highlight row
  notableRows.querySelectorAll('tr.row-highlighted').forEach((r) => r.classList.remove('row-highlighted'))
  const escapedSpecies = String(species).replace(/\\/g, '\\\\').replace(/"/g, '\\"')
  const newBtn = notableRows.querySelector(`.species-btn[data-species="${escapedSpecies}"]`)
  const newRow = newBtn?.closest('tr')
  if (newRow) newRow.classList.add('row-highlighted')

  // Zoom map to point(s)
  const pts = speciesMarkers.get(species)
  if (!pts || pts.length === 0 || !map) return
  if (map) map.invalidateSize()
  const targetPt = pickBestSpeciesPoint(pts)
  if (pts.length === 1 && targetPt) {
    map.setView([targetPt.lat, targetPt.lng], Math.max(map.getZoom(), 13), { animate: true })
    openObservationPopup(targetPt)
  } else {
    const lats = pts.map((p) => p.lat)
    const lngs = pts.map((p) => p.lng)
    map.fitBounds(L.latLngBounds([Math.min(...lats), Math.min(...lngs)], [Math.max(...lats), Math.max(...lngs)]), { padding: [40, 40], maxZoom: 13, animate: true })
    if (targetPt) {
      window.setTimeout(() => openObservationPopup(targetPt), 120)
    }
  }
})

document.querySelector('.notable-table thead').addEventListener('click', (event) => {
  const th = event.target.closest('th[data-sort]')
  if (!th) return
  const col = th.dataset.sort
  if (sortState.col === col) {
    sortState.dir = sortState.dir === 'desc' ? 'asc' : 'desc'
  } else {
    sortState.col = col
    sortState.dir = 'desc'
  }
  applySortAndRender()
})

sortModeBtn?.addEventListener('click', () => {
  if (sortState.col === 'distance') {
    sortState = { col: 'aba', dir: 'desc' }
  } else {
    sortState = { col: 'distance', dir: 'asc' }
    ensureDistanceKmForCurrentTableData()
  }
  applySortAndRender()
})

notableRows.addEventListener('change', (event) => {
  const cb = event.target.closest('.obs-vis-cb')
  if (!cb) return
  const species = cb.dataset.species
  if (!species) return
  const show = cb.checked
  if (show) hiddenSpecies.delete(species)
  else hiddenSpecies.add(species)
  const pts = speciesMarkers.get(species)
  if (pts) { pts.forEach((p) => { p.hidden = !show }); fastCanvasOverlay?.redraw() }
  // Sync toggle-all checkbox state
  const toggleAll = document.querySelector('#toggleAllVis')
  if (toggleAll) {
    const total = notableRows.querySelectorAll('.obs-vis-cb').length
    if (hiddenSpecies.size === 0) { toggleAll.checked = true; toggleAll.indeterminate = false }
    else if (hiddenSpecies.size >= total) { toggleAll.checked = false; toggleAll.indeterminate = false }
    else { toggleAll.indeterminate = true }
  }
})

document.querySelector('#toggleAllVis')?.addEventListener('change', (event) => {
  const show = event.target.checked
  event.target.indeterminate = false
  speciesMarkers.forEach((pts, species) => {
    if (show) { hiddenSpecies.delete(species); pts.forEach((p) => { p.hidden = false }) }
    else { hiddenSpecies.add(species); pts.forEach((p) => { p.hidden = true }) }
  })
  fastCanvasOverlay?.redraw()
  notableRows.querySelectorAll('.obs-vis-cb').forEach((cb) => { cb.checked = show })
})

setMode('map')

let appBooted = false

async function bootAppOnce() {
  if (appBooted) return
  appBooted = true

  hideApiKeyGate()
  await checkApi()

  const launchUrl = new URL(window.location.href)
  const forceFreshLocation = launchUrl.searchParams.get('force_location') === '1'
  if (forceFreshLocation) {
    launchUrl.searchParams.delete('force_location')
    window.history.replaceState({}, '', launchUrl.toString())
  }

  // Default fallback: Woodland, CA (inside Yolo County). Used when geolocation fails/is blocked.
  const YOLO_DEFAULT_LAT = 38.6785
  const YOLO_DEFAULT_LNG = -121.7733

  const startFromDefaultCounty = async (reasonLabel = 'default') => {
    const lat = YOLO_DEFAULT_LAT
    const lng = YOLO_DEFAULT_LNG
    lastUserLat = lat
    lastUserLng = lng
    const requestId = ++latestLocationRequestId
    locationStatus.className = 'badge warn'
    locationStatus.textContent = 'Default'
    locationDetail.textContent = `Yolo County, CA · ${reasonLabel}`
    resetMapLoadState()
    updateUserLocationOnMap(lat, lng, null)

    try {
      perfStart('county')
      const countyContextPromise = updateCountyForLocation(lat, lng, requestId)
      const notablesPromise = loadCountyNotables(lat, lng, null, requestId, null, false)
      const countyContext = await countyContextPromise
      perfEnd('county')
      if (!isStaleLocationRequest(requestId)) {
        if (countyContext?.countyLabel) {
          locationDetail.textContent = `${countyContext.countyLabel} · ${reasonLabel}`
        }
        const regionForZoom = String(countyContext?.countyRegion || '').toUpperCase() || null
        if (regionForZoom) zoomToActiveCounty(latestCountyContextGeojson, regionForZoom)
      }
      await notablesPromise
      updateRuntimeLog()
      return true
    } catch (error) {
      console.error('default county startup failed:', error)
      updateRuntimeLog()
      return false
    }
  }

  // Default: request current location.
  const located = await requestUserLocation(false)
  if (located) return

  // Fallback: if GPS is blocked/unavailable, load Yolo County, CA by default.
  if (!forceFreshLocation) {
    await startFromDefaultCounty('no location')
  }
}

function ensureApiKeyOrGate() {
  maybeSeedEbirdApiKeyFromUrl()
  const key = getStoredEbirdApiKey()
  if (key) {
    void bootAppOnce()
    return true
  }
  showApiKeyGate('')
  return false
}

apiKeyOpenBtn?.addEventListener('click', () => {
  window.open('https://ebird.org/api/keygen', '_blank', 'noopener,noreferrer')
})

apiKeyToggleBtn?.addEventListener('click', () => {
  const currentlyText = apiKeyInput?.type === 'text'
  setApiKeyInputVisibility(!currentlyText)
  try { apiKeyInput?.focus() } catch { /* ignore */ }
})

apiKeyCloseBtn?.addEventListener('click', () => {
  hideApiKeyGate()
})

apiKeySaveBtn?.addEventListener('click', async () => {
  if (apiKeyError) apiKeyError.textContent = ''
  const candidateKey = normalizeEbirdApiKey(apiKeyInput?.value)
  if (!candidateKey) {
    if (apiKeyError) apiKeyError.textContent = 'Paste your eBird API key to continue.'
    return
  }

  if (apiKeySaveBtn) apiKeySaveBtn.disabled = true
  try {
    const test = await testEbirdApiKey(candidateKey)
    if (!test.ok) {
      if (apiKeyError) apiKeyError.textContent = test.message || 'API key test failed.'
      return
    }
    const ok = setStoredEbirdApiKey(candidateKey)
    if (!ok) {
      if (apiKeyError) apiKeyError.textContent = 'Could not save API key (storage blocked?).'
      return
    }
    hideApiKeyGate()
    void bootAppOnce()
  } finally {
    if (apiKeySaveBtn) apiKeySaveBtn.disabled = false
  }
})

apiKeyInput?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault()
    apiKeySaveBtn?.click()
  }
})

// Gate startup on API key.
ensureApiKeyOrGate()

function sleep(ms) {
  return new Promise((resolve) => { window.setTimeout(resolve, ms) })
}

function maybeStartStressTestRunner() {
  const url = new URL(window.location.href)
  if (url.searchParams.get('stress') !== '1') return

  const key = getStoredEbirdApiKey()
  if (!key) {
    console.warn('[stress] Missing API key; enter it first, then reload with ?stress=1')
    return
  }

  const states = ['US-CA', 'US-AZ', 'US-OR', 'US-WA', 'US-NV', 'US-ID', 'US-UT', 'US-CO']
  const daysBackOptions = [1, 3, 7, 14]
  const intervalMs = Math.max(800, Number(url.searchParams.get('stress_ms')) || 3500)
  let step = 0
  let inFlight = false
  let stopped = false

  const tick = async () => {
    if (stopped || inFlight) return
    inFlight = true
    try {
      await bootAppOnce()

      const state = states[step % states.length]
      const daysBack = daysBackOptions[step % daysBackOptions.length]

      await activateStateByRegion(state)
      await sleep(300)

      if (headerDaysBackSelect) {
        const desired = String(daysBack)
        const hasOption = Array.from(headerDaysBackSelect.options).some((opt) => opt.value === desired)
        if (hasOption) {
          headerDaysBackSelect.value = desired
          headerDaysBackSelect.dispatchEvent(new Event('change', { bubbles: true }))
        }
      }

      if (Array.isArray(countyPickerOptions) && countyPickerOptions.length > 0) {
        const cap = Math.min(countyPickerOptions.length, 8)
        const pick = countyPickerOptions[step % cap]
        if (pick?.countyRegion) {
          activateCountyByRegion(pick.countyRegion, pick.lat, pick.lng, pick.countyName)
        }
      }

      step += 1
      console.log(`[stress] step=${step} state=${state} days=${daysBack} counties=${countyPickerOptions.length}`)
    } catch (error) {
      stopped = true
      console.error('[stress] stopped due to error:', error)
      handleUnhandledUiFault('stress-runner', error)
    } finally {
      inFlight = false
    }
  }

  console.log(`[stress] Starting: interval=${intervalMs}ms (stop by removing ?stress=1)`)
  window.setInterval(() => { void tick() }, intervalMs)
  void tick()
}

maybeStartStressTestRunner()

if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    const registrations = await navigator.serviceWorker.getRegistrations()
    await Promise.all(registrations.map((registration) => registration.unregister()))

    if ('caches' in window) {
      const keys = await caches.keys()
      await Promise.all(keys.map((key) => caches.delete(key)))
    }
  })
}

window.addEventListener('error', (event) => {
  handleUnhandledUiFault('window-error', event?.error || new Error(event?.message || 'Unknown runtime error'))
})

window.addEventListener('unhandledrejection', (event) => {
  handleUnhandledUiFault('unhandled-rejection', event?.reason || new Error('Unhandled promise rejection'))
})
